%!TEX root = draft.tex

\section{Reference Implementation}
\label{sec:reference implementation}

In this section, we propose an abstract implementation called reference implementation, which will be used as specification in simulation proof of later section.


\subsection{Reference Implementation Definition}
\label{subsec:reference implementation definition} 

An labeled transition system (LTS, for short) is a tuple $A = (Q,\Sigma,\rightarrow,q_0)$, where $Q$ is a set of states, $\Sigma$ is an alphabet of transition labels, $\rightarrow \subseteq Q \times \Sigma \times Q$ is a transition relation and $q_0$ is the initial state. In this paper, the specification and the semantics of CRDT implementation will be modelled as LTS. Then, checking eventual consistency is a instance of a more general notion of refinement between LTS where only actions in a specific alphabet $\Sigma$ is observable. It has been shown that refinement is equivalent to the existence of backward simulations, modulo the addition of history variables that record events in the implementation, and to the existence of forward simulations provided that the right-hand side LTS B is $\Sigma$-deterministic \cite{Abadi:1991,Lynch:1995}. In this paper we focus on proofs based on forward simulations because they are easier to automatize, and we need to ensure that reference implementations are deterministic. 

In this paper, we focus on operation-based CRDT algorithm, where each operation is done locally (without communication between replicas), and when a replica does a update operation, it will broadcast the operation to all other replica. Here we assume the set of replica identifier is already fixed into $RId=\{1,\ldots,n\}$. 

The operations of a CRDT are divided into two kinds: query operation and update operation. 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] A query operation does not influence ``abstract state''. Or we can say, if $(A,<) \in Spec(o)$ for some and $A' \subseteq A$ is obtained from $A$ by erasing some query operations, then $(A',< \cap (A' \times A')) \in Spec(o)$. 

\item[-] A update operation influences ``abstract state''. 
\end{itemize} 

%Let $qry(M,D,RId,OId)$ (resp., $upd(M,D,RId,OId)$) be the set of query operations (resp., update operations) using method in $M$, arguments and return values in $D$, replica identifiers in $RId$ and operation identifiers in $OId$. 

Given a specification $Spec$, its reference implementation is given as an LTS $RImp(Spec) = (Q,\Sigma,\rightarrow,q_0,li,vis)$, where 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $Q = (uO,ro,del)$ is the set of states. Here $updOp$ is a set of update operations, $ro$ is the replica order among operations in $updOp$, and $del \subseteq uO \times uO$ is the deliver order. Deliver order only relate operations with different replica identifier. 
    
    We require that the tuple of $Q$ enough for checking correctness of operations. Sometimes, if $Spec$ use more information when checking correctness of operations, $Q$ should contain more information. For example, in distributed list specification \cite{Attiya:2016}, a list order is added to tuples of $Q$. 
    
\item[-] $\Sigma$ is the set of operations using method in $M$, arguments and return values in $D$, replica identifiers in $RId$ and operation identifiers in $OId$. 

\item[-] 
\end{itemize}








