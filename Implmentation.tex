%!TEX root = draft.tex

\section{Implementation}
\label{sec:implementation}

{\color {red}In CRDT algorithm, each replica has a local state. When a replica do a operation, it is done locally without synchronization with other replica. If this is an update operation, then this replica will broadcast a message to all other replicas.} Let $\mathbb{L}$ be the set of local state, and $\mathbb{MSG}$ be the set of messages. Each message is of the form $(d,r_s,r_d)$ where $r_s \in \mathbb{R}$ is the identifier of replica that generates this message, and $r_d \in \mathbb{R}$ is the destination replica identifier of this message. A CRDT implementation $\mathit{imp}$ is defined as a tuple $(\rightarrow_o,\rightarrow_m,d_0,f_{\mathit{arb}}, \Sigma_e)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\rightarrow_o: \mathbb{L} \times \mathbb{M} \times \mathbb{D} \times \mathbb{R} \rightarrow \mathbb{L} \times \mathbb{D} \times \mathit{Pow}(\mathbb{MSG})$ shows how method update local state and generate messages. $(d,m,a,r) \rightarrow_o (d',b,\mathit{msgs})$ represents that, when the local state of replica $r$ is $d$, if we call method $m$ with argument $a$ in replica $r$, then we obtain return value $b$, change the local state of replica $r$ into $d'$, and generate a set $\mathit{msgs}$ of messages. Here $\mathit{Pow}(\mathbb{MSG})$ is the power set of $\mathbb{MSG}$. If $m \in \mathbb{U}$, then $\mathit{msgs} = \{ (x,r,r') \vert r' \in \mathbb{R} \wedge r \neq r' \}$ for some $x$. Otherwise, $\mathit{msgs} = \emptyset$. {\color {red}The violation of pre-condition of method is modeled by mapping to $\mathit{undef}$.}

\item[-] $\rightarrow_m: \mathbb{L} \times \mathbb{R} \times \mathbb{MSG} \rightarrow \mathbb{L}$. $(d,r,\mathit{msg}) \rightarrow_m d'$ represents that, if the local state of replica $r$ is $d$ and we apply message $\mathit{msg}$, then we obtain local state $d'$. {\color {red}The violation of pre-condition of applying a message is modeled by mapping to $\mathit{undef}$.}

\item[-] $d_0 \in \mathbb{L}$ is the initial local state.

\item[-] $f_{\mathit{arb}}$ takes the local states of each replica, and a set of messages as arguments, and returns a total order over elements, while each element represents an operation. Let $\Sigma_e$ be the set of such elements.

    %To do this, we need a method to extract elements from local states and messages. Let the set of extracted elements to be $\Sigma_e$.

%\item[-] $f_{o}: \Sigma_{\mathtt{RD}}^{\vert \mathbb{R} \vert} \times Pow(\mathbb{MSG}) \Rightarrow Pow(\Sigma_o)$, where $\Sigma_o$ is a set of elements and each element represents an operation. Given replica data of each replica, $f_{o}$ is used to obtain the ``operations'' known by current state of implementation.

%\item[-] $f_{arb}: \Sigma_{\mathtt{RD}}^{\vert \mathbb{R} \vert} \times Pow(\mathbb{MSG}) \Rightarrow \Sigma_o^*$. Given replica data of each replica and messages, $f_{arb}$ is used to obtain the arbitration relation.
\end{itemize}


The semantics of $\mathit{imp}$ is given as an LTS $\mathit{Sem}(\mathit{imp}) = (Q,\Sigma,\rightarrow,q_0)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state $(\mathit{data},\mathit{msgs}) \in Q$ contains two tuples: $\mathit{data}: \mathbb{R} \rightarrow \mathbb{L}$ is the local state of each replica, $\mathit{msgs} \subseteq \mathbb{MSG}$ is the set of messages that are waiting to be applied.

\item[-] $\Sigma$ contains two kinds of transition labels. $m(a,b,r,\mathit{arb})$ represents that a $m(a) \Rightarrow b$ operation is done in replica $r$ and the arbitration order is changed into $\mathit{arb}$. $\mathit{apply}(\mathit{msg})$ represents applying message $\mathit{msg}$.

\item[-] $\rightarrow$ is the transition relation and is defined as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] %{\color {red}When doing operations, we keep messages unique.}

    $\begin{array}{l c} \bigfrac{ (\mathit{data}[r],m,a,r) \rightarrow_o (d,b,\mathit{msgs}'), \mathit{msg} \cap \mathit{msgs}' = \emptyset, f_{\mathit{arb}}((\mathit{data}[r:d], \mathit{msgs} \cup \mathit{msgs}')) = \mathit{arb}} {(\mathit{data},\mathit{msgs}) {\xrightarrow{(m,a,b,r,\mathit{arb})}} (\mathit{data}[r:d], \mathit{msgs} \cup \mathit{msgs}')} \end{array}$

    \item[-] {\color {red} When a message is applied, we remove it from $\mathit{msgs}$.}

    $\begin{array}{l c} \bigfrac{ \mathit{msg} = (\_,\_,r) \in \mathit{msgs},(\mathit{data}[r],r,\mathit{msg}) \rightarrow_m d } {(\mathit{data},\mathit{msgs}) {\xrightarrow{\mathit{apply}(\mathit{msg})}} (\mathit{data}[r:d],\mathit{msgs} - \{ \mathit{msg} \})} \end{array}$
    \end{itemize}

\item[-] $q_0 = (data_0,\emptyset)$ is the initial state, $data_0$ maps each replica identifier into $d_0$.
\end{itemize}

An trace of $\mathit{imp}$ satisfies causal delivery, if given $o_1 <_{\mathit{hb}} o_2$, then we can apply message generated by $o_2$ on a replica, if the message generated by $o_1$ has already been applied on this replica. The semantics of $\mathit{imp}$ with causal delivery is given as an LTS $\mathit{Sem}(\mathit{imp})_{\mathit{cd}}$, and we give its detailed definition in Appendix \ref{sec:appendix definitions and proofs of section implementation}. Each state of $\mathit{Sem}(\mathit{imp})_{\mathit{cd}}$ is a tuple $(\mathit{data},\mathit{msgs},\mathit{msghb})$. {\color {red}Here $\mathit{msghb}$ record the happen-before relation between messages with same destination replica, and we can only apply a minimal messages of $\mathit{msgs}$ w.r.t $\mathit{msghb}$.}




\noindent {\bf Example 6. OR-set algorithms of \cite{Shapiro:2011}}: This algorithm assumes causal delivery. Its tuple are as follows:

{\color {red}
\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathbb{L} = \{ (S,\mathit{ctr}) \vert S \subseteq \mathbb{D} \times (\mathbb{R} \times \mathbb{N}), \mathit{ctr} \in \mathbb{N} \}$. Elements of $S$ are of form $(a,id)$, and $\mathit{ctr}$ is per-replica counter to make $id$ unique.

\item[-] $(S,\mathit{ctr}) \xrightarrow[\mathit{msgs} = \{ (a,\mathit{id},r,r') \vert r' \neq r \}]{(\mathit{add},a,r)}_o (S \cup \{ (a,\mathit{id}) \}, \mathit{ctr}+1)$ and $\mathit{id} = (r,\mathit{ctr})$.

\item[-] $(S,\mathit{ctr}) \xrightarrow[\mathit{msgs} = \{ (a,S'',r,r') \vert r' \neq r \} ]{(\mathit{rem},a,r)}_o (S \setminus \{ (a,id) \in S \}, \mathit{ctr})$, $S'' = \{ id \vert (a,id) \in S \} \neq \emptyset$.

\item[-] $(S,\mathit{ctr}) \xrightarrow[\mathit{msgs} = \emptyset]{(\mathit{lookup},a,\mathit{true},r)}_o (S, \mathit{ctr})$, if there exists $\mathit{id}$ such that $(a,\mathit{id}) \in S$.

\item[-] $(S,\mathit{ctr}) \xrightarrow[\mathit{msgs} = \emptyset]{(\mathit{lookup},a,\mathit{false},r)}_o (S, \mathit{ctr})$, if $(a,\mathit{id}) \notin S$ for each $\mathit{id}$.

\item[-] $(S,\mathit{ctr}) \xrightarrow{\mathit{apply}((a,id,\_,r))}_m (S \cup \{ (a,id) \}, \mathit{ctr})$.

\item[-] $(S,\mathit{ctr}) \xrightarrow{\mathit{apply}((a,S',\_,r))}_m (S \setminus \{ (a,id) \vert id \in S' \}, \mathit{ctr})$.

\item[-] $d_0 = (\emptyset,0)$.

\item[-] $\Sigma_e$ is the union of (1) $(a,id)$ in either $\mathit{data}[\_].S$, or $\exists (a,S',\_,\_) \in \mathit{msgs}$ and $id \in S'$, and (2) $(a,S',r)$ in $\mathit{msgs}$.

\item[-] $f_{\mathit{arb}}$ always return $\emptyset$.
\end{itemize}
}



\noindent {\bf Example 7. woot algorithms \cite{Oster:2006}}: Woot algorithm does not assume causal delivery. A W-character $x$ is a five-tuple $(\mathit{id},a,v,\mathit{id}_p,\mathit{id}_n)$, where $\mathit{id} \in \mathbb{R} \times \mathbb{N}$ is the identifier of $x$; $a$ is the value of $x$; $v \in \{ \mathit{true},\mathit{false} \}$ indicates whether $x$ is visible or tombstone; $\mathit{id}_p$ and $\mathit{id}_n$ are the identifier of previous and next W-character of $x$, while each W-character is generated to be inserted in between two W-characters.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathbb{L} = \{ (\mathit{ctr}, \mathit{str}) \vert \mathit{ctr} \in \mathbb{N}, \mathit{str}$ is a string of W-character $\}$. $\mathit{str}$ is the list seen by this replica, and $\mathit{ctr}$ is per-replica counter to make unique identifier. Let $<_{\mathit{ts}}$ be the order of time stamp, such that $(r_1,c_1) <_{\mathit{ts}} (r_2,c_2)$, if $(c_1 < c_2) \vee (c_1 = c_2 \wedge r_1 < r_2)$. Given a sequence $s$, let $<_s$ be order of $s$, such that $a <_s b$, if they are both in $s$ and $a$ has smaller index.

{\color {red}
\item[-] $(\mathit{ctr},\mathit{str}) \xrightarrow[\mathit{msgs} = \{ (y,r,r') \vert r' \neq r \}]{(\mathit{rem},x,r)}_o (\mathit{ctr},\mathit{str}')$, if there exists $y = (\_,x,\textit{true},\_,\_) \in \mathit{str}$, and $\mathit{str}'$ is obtained from $\mathit{str}$ by changing the flag of $y$ into $\mathit{false}$.

\item[-] $(\mathit{ctr},\mathit{str}) \xrightarrow[\mathit{msgs} = \emptyset]{(\mathit{read},l,r)}_o (\mathit{ctr},\mathit{str})$, where $l$ is the sequence of values of elements in $\mathit{str}$ with flag $\mathit{true}$.

\item[-] $(\mathit{ctr},\mathit{str}) \xrightarrow[\mathit{msgs} = \{ (w_3,w_1,w_2,r,r') \vert r' \neq r \}]{(\mathit{add},x,\mathit{pos},r)}_o (\mathit{ctr}+1,\mathit{str}')$: Assume $\mathit{str}[\mathit{pos}]=w_1$ and $\mathit{str}[\mathit{pos}+1]=w_2$, then let $w_3 = ((r,\mathit{ctr}),x,\mathit{true},w_1.\mathit{id},w_2.\mathit{id})$, and $\mathit{str}' = \mathit{insert}(w_3,w_1,w_2)$ for the recursive function defined in Algorithm \ref{alg:insert}. Notions of Algorithm \ref{alg:insert} are as follows: Given $d_u = (\mathit{id},a,v,\mathit{id}_p,\mathit{id}_n)$, $\mathit{pre}(d_u) = \mathit{id}_p$ and $\mathit{next}(d_u)=\mathit{id}_n$; $\mathit{subseq}(\mathit{str},c_p,c_n)$ returns the sub-sequence of $\mathit{str}$ between $c_p$ and $c_n$; $\mathit{pos}(\mathit{str},c_n)$ returns the position of $c_n$ in $\mathit{str}$; $\mathit{ins}(\mathit{str},c,\mathit{pos})$ inserts $c$ into $\mathit{str}$ at position $\mathit{pos}$.

\item[-] $(\mathit{ctr},\mathit{str}) \xrightarrow{\mathit{apply}((\_,a,\_,\_,\_))}_m (\mathit{ctr},\mathit{str}')$, if $\mathit{str}$ contains W-character $w$ with value $a$, and $\mathit{str}'$ is obtained from $\mathit{str}$ by changing the flag of $w$ into $\mathit{false}$.

\item[-] $(\mathit{ctr},\mathit{str}) \xrightarrow{\mathit{apply}((w_1,w_2,w_3,\_,\_))}_m (\mathit{ctr},\mathit{str}')$, if $\mathit{str}$ contains $w_2$ and $w_3$, and $\mathit{str}' = \mathit{insert}(w_1,w_2,w_3)$ for the recursive function defined in Algorithm \ref{alg:insert}.
}

\item[-] $d_0 = (0,\epsilon)$.

\item[-] $\Sigma_e$ is the union of (1) W-character $w$ in local states and messages, and (2) $(w_1,w_2,w_3,r,\_)$ in messages.

\item[-] {\color {red}$f_{arb}$ is obtained by applying $\mathit{insert}$ to all W-character in $\mathit{str}$ from $\epsilon$. \cite{Oster:2006} proves convergence. We give another convergence proof in Appendix \ref{sec:appendix definitions and proofs of section implementation}. We prove that, if operations in $S$ are convergent and $o_1$, $o_2$ replies on $S$, then applying $S \cup \{ o_1,o_2 \}$ also convergent.}

%$f_{arb}$ orders $x$ and $y$ as follows: Given $x = (id,a,v,id_p,id_n)$, we say that $x$ relies on W-character with identifiers $id_p$ and $id_n$. We say that $(x,y) \in f_{arb}$, if one of the following cases holds: (1) there exists $z_1,\ldots,z_k$, such that $x=z_1$, $y=z_k$, and for each $u$, $next(z_u)=z_{u+1} \vee pre(z_{u+1}) = z_u$. (2) Starting from $\epsilon$, we put all elements that $y$ and $z$ rely, then we put $y$ and $z$, and find that $y$ is before $z$ in $str$ of the resulting local state.


\end{itemize}

\begin{algorithm}[t]
\KwIn {$c$, $c_p$, $c_n$}
\KwOut{a W-character string}

Let $s' = \mathit{subseq}(\mathit{str},c_p,c_n)$ \;

\If {$s' = \epsilon$}
{
    \Return $\mathit{ins}(\mathit{str},c,\mathit{pos}(\mathit{str},c_n))$\;
}
\Else
{
    let $L = c_p \cdot d_0 \cdot \ldots \cdot d_k \cdot c_n$, where $d_0,\ldots,d_k$ are the W-char $d_u$ in $s'$ such that $\mathit{pre}(d_u) \leq_{\mathit{str}} c_p$ and $c_n \leq_{\mathit{str}} \mathit{next}(d_u)$\;
    let $j = 1$\;
    {\bf while} $(j < \vert L \vert -1 \wedge L[j] <_{\mathit{ts}} c)$\ {\bf do}
    {
        $j = j+1$\;
    }
    return $\mathit{insert}(c,L[i-1],L[i])$\;
}
\caption{$\mathit{insert}$}
\label{alg:insert}
\end{algorithm}


















\forget{
\section{Implementation}
\label{sec:implementation}

Let $\mathbb{RD}$ be the set of data of replica. Let $\mathbb{MSG}$ be the set of messages. Each message is of the from $msg=(dat,sorR,desR)$ and is generated when some replica does an operation. Here $dat \in \mathbb{RD}$ is the information carried by message, $sorR,desR \in \mathbb{R}$ are the replica identifier of the replica that launched the message and the destination replica of this message, respectively.

A CRDT implementation $imp$ is defined as a tuple $(Mth,Apl,Pred,InitD)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $Mth: \mathbb{M} \times \mathbb{D} \times \mathbb{RD} \times \mathbb{R} \rightarrow \mathbb{D} \times \mathbb{RD} \times Pow(\mathbb{MSG})$. $Mth(m,a,d,r) = (b,ar,d',msgs)$ means that, if the data of replica $r$ is $d$, then if we call method $m$ with argument $a$ in replica $r$, then we obtain return value $b$ and change the data of replica $r$ into $d'$, and generate a set $msgs$ of messages. Here $Sub(\mathbb{RD})$ means we only return a part

    Here if $m$ is an update method, then $msgs = \{ (dat,r,r') \vert r' \in \mathbb{R} \wedge r \neq r' \}$ for some $dat$. Otherwise, if $m(a,b)$ is a query operation, then $msgs = \emptyset$.

\item[-] $Apl: \mathbb{RD} \times \mathbb{MSG} \rightarrow \mathbb{RD}$. $Apl(d,msg) = d'$ means that, if the current replica data is $d$ and we apply message $msg$, then we obtain replica data $d'$.

\item[-] $Pred: (\mathbb{M} \times \mathbb{D} \times \mathbb{RD} \rightarrow \{ \mathit{true},\mathit{false} \}) \cup (\mathbb{RD} \times \mathbb{MSG} \rightarrow \{ \mathit{true},\mathit{false} \})$ is used to check whether a method can proceed, or whether a message can be applied.

\item[-] $InitD \in \mathbb{RD}$ is the initial replica data.
\end{itemize}

The semantics of $imp$ is given as an LTS $\llbracket imp \rrbracket = (Q,\Sigma,\rightarrow,q_0)$ \footnote{{\color {red} For some implementations, more information may be used as tuple of state of $\llbracket imp \rrbracket$. Such information are only for make transition labels clear and do not influence execution. For example, for distributed list algorithm, the order of all known items may be used as a argument. Similarly, we may add more information into transition labels when it is necessary.}}, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state $(repD,msgs,<_{sd}) \in Q$ contains three tuples. Here $repD: RId \rightarrow RepD$ is the replica data of each replica, $msgs \subseteq Msg$ is the set of messages, $<_{sd} \subseteq Meg \times Msg$ is used to record the order of messages. $<_{sd}$ only relates messages with the same source replica identifier and with the same destination replica identifier.

Let $msgs(r,r') = \{ (\_,r,r') \in msgs \}$ denote the set of messages in $msgs$ whose source replica is $r$ and whose destination replica is $r'$. $\forall r,r' \in RId$, $<_{sd}$ is a irreflexive and acyclic total order on $msgs(r,r')$. %We also require that the transitive closure of $<_{ro}$ on operations being acyclic.
The reason we introduce $<_{sd}$ into state is for defining simulation relation in the next section.

\item[-] $\Sigma = \{ m(a,b,r), apply(msg) \vert m \in M, a,b \in D, r \in RId, msg \in Msg \}$ is the set of transition labels.

\item[-] $\rightarrow$ is the transition relation and is defined as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Doing an operation:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msg \cap msgs' = \emptyset} {(repD,msgs,<_{sd}) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',<_{sd} \odot msgs')} \end{array}$

    Here $<_{sd} \odot msgs'$ is obtained from $<_{sd}$ by adding  $(m_1,m_2)$, when $m_1 \in msgs$, $m_2 \in msgs'$, the souce replica of $m_1$ is the same as that of $m_2$, and the desitination replica of $m_1$ is the same as that of $m_2$. {\color {red} We also require that $msg \cap msgs' = \emptyset$. This implies that no duplicate messages will be generated.}

    Recall that, if $m(a,b)$ is a query operation, then $msgs' = \emptyset$.

    \item[-] Applying a message:

    $\begin{array}{l c} \bigfrac{ m = (\_,\_,r) \in msgs,Apl(repD[r],m) = d } {(repD,msgs,<_{sd}) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \},<_{sd}-m )} \end{array}$
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset)$.
\end{itemize}

We say that an execution of $\llbracket imp \rrbracket$ satisfies causal delivery, for each pair of update operations $(o_1,o_2)$, if $o_1 <_{hb} o_2$, let $(dat_1,r_1,\_)$ and $(dat_2,r_2,\_)$ be the message generated by $o_1$ and $o_2$, then for each replica $r$, the applying of $(dat_1,r_1,r)$ occurs before $(dat_2,r_2,r)$. The semantics of $imp$ with causal delivery is given as an LTS $\llbracket imp \rrbracket_{cd} = (Q_{cd},\Sigma,\rightarrow_{cd},q_{cd0})$, where

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $Q_{cd}$ is for the from $(repD,msgs,<)$, where $repD$ and $msgs$ is the same as that in $\llbracket imp \rrbracket$, and $< \subseteq (msgs \times msgs) \cup (msgs \times RId)$ is a transitive, acyclic and irreflexive relation. $<$ is used to record the happen-before relation between operations of messages. %$(m_1,m_2) \in <$ represents that the $op(m_1)$ happen before $op(m_2)$, while $(m,r) \in <$ represents that $op(m)$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.
    $(m_1,m_2) \in <$ represents that the operation generating $m_1$ happens before the operation generating $m_2$, while $(m,r) \in <$ represents that the operation generating $m$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.

\item[-] $\rightarrow_{cd}$ is the transition relation and contains three kinds of operations:

    The first kind is transitions of query operation. In this situation, messages and $<$ relations do not change:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,\emptyset)} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs,<)} \end{array}$



\item[-] The second kind is transitions of update operation :

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msgs' = \{ (dat,r,r') \vert r' \in RId \wedge r \neq r' \} \ for \ some \ dat} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',< \otimes dat)} \end{array}$

    Let us explain $< \otimes dat$. $< \otimes dat$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $\forall k' \in RId$, in $msgs(k')$, if $m_1 < r$, then erase $(m_1,r)$, add $(m_1,(dat,r,k'))$,

    \item[-] $\forall k' \in RId$, if $m_2$ is the maximal message among $\{ (\_,r,k') \}$ w.r.t $<$, then add $(m_2,(dat,r,k'))$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] The third kind is transitions of applying messages:

    $\begin{array}{l c} \bigfrac{ m = (dat,r_1,r) \in msgs,Apl(repD[r],m) = d, m \ is \ minimal \ w.r.t \ < among \ messages \ in \ msgs(r) } {(repD,msgs,<) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \}, < \otimes m )} \end{array}$

    Let us explain $< \otimes m$. $< \otimes m$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] First, remove $m$ from $<$ while keep orders of other elements in $<$ unchanged.

    \item[-] Then, $\forall k' \neq r$, if $(dat,r_1,k') \in msgs(k')$, then add $((dat,r_1,k'),k')$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset,\emptyset)$.
\end{itemize}

The following lemma states that, $\llbracket imp \rrbracket_{cd}$ contains the set of causal delivery executions of $\llbracket imp \rrbracket$. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section implementation}.

\begin{lemma}
\label{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}

$\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.
\end{lemma}
}





















\forget
{
In this section, we give our formation of CRDT algorithms (implementation) and their semantics.

In a CRDT algorithm, each replica stores a copy of shared data and possibly some auxiliary data. For example, in OR-set algorithm of \cite{Bieniusa:2012}, the shared data consists of a set $E$ of current item and a set $T$ of tombstone, and the auxiliary data is a counter used to ensure the uniqueness of item identifier.

Let $RepD$ be the set of data of replica. Let $Msg$ be the set of messages. Each message is of the from $msg=(dat,sorR,desR)$ and is generated since some replica does an operation. Here $dat$ is some information, %and we assume that we can use a function $op(dat)$ to obtain the operation that generates $msg$,
$sorR \in RId$ indicates that which replica launches this operation, and $desR \in RId$ indicates the destination replica identifier of this message. %Let $data(msg)=dat$ be a function that reads the data of a message.

Then a CRDT implementation $imp$ is defined as a tuple $(Mth,Apl,InitD)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $Mth: M \times D \times PRD \times RId \rightarrow D \times PRD \times Pow(Mes)$. $Mth(m,a,d,rid) = (b,d',msgs)$ means that, if the current replica data is $d$ and we call method $m$ with argument $a$ in replica $rid$, then the resulting replica data is $d'$, we obtain return value $b$, and generate a set $msgs$ of messages. Here we assume that if $m$ is an update method, then $msgs = \{ (dat,rid,r') \vert r' \in RId \wedge rid \neq r' \}$ for some $dat$. %where $op(dat)$ uses method $m$ with argument $a$ and return value $b$.

    We also assume that, if $m(a,b)$ is a query operation, then $msgs = \emptyset$.

\item[-] $Apl: RepD \times Msg \rightarrow RepD$. $Apl(d,msg) = d'$ means that, if the current replica data is $d$ and we apply message $msg$, then we obtain replica data $d'$.

\item[-] $InitD \in RepD$ is the initial replica data.
\end{itemize}

The semantics of $imp$ is given as an LTS $\llbracket imp \rrbracket = (Q,\Sigma,\rightarrow,q_0)$ \footnote{{\color {red} For some implementations, more information may be used as tuple of state of $\llbracket imp \rrbracket$. Such information are only for make transition labels clear and do not influence execution. For example, for distributed list algorithm, the order of all known items may be used as a argument. Similarly, we may add more information into transition labels when it is necessary.}}, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state $(repD,msgs,<_{sd}) \in Q$ contains three tuples. Here $repD: RId \rightarrow RepD$ is the replica data of each replica, $msgs \subseteq Msg$ is the set of messages, $<_{sd} \subseteq Meg \times Msg$ is used to record the order of messages. $<_{sd}$ only relates messages with the same source replica identifier and with the same destination replica identifier.

Let $msgs(r,r') = \{ (\_,r,r') \in msgs \}$ denote the set of messages in $msgs$ whose source replica is $r$ and whose destination replica is $r'$. $\forall r,r' \in RId$, $<_{sd}$ is a irreflexive and acyclic total order on $msgs(r,r')$. %We also require that the transitive closure of $<_{ro}$ on operations being acyclic.
The reason we introduce $<_{sd}$ into state is for defining simulation relation in the next section.

\item[-] $\Sigma = \{ m(a,b,r), apply(msg) \vert m \in M, a,b \in D, r \in RId, msg \in Msg \}$ is the set of transition labels.

\item[-] $\rightarrow$ is the transition relation and is defined as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Doing an operation:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msg \cap msgs' = \emptyset} {(repD,msgs,<_{sd}) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',<_{sd} \odot msgs')} \end{array}$

    Here $<_{sd} \odot msgs'$ is obtained from $<_{sd}$ by adding  $(m_1,m_2)$, when $m_1 \in msgs$, $m_2 \in msgs'$, the souce replica of $m_1$ is the same as that of $m_2$, and the desitination replica of $m_1$ is the same as that of $m_2$. {\color {red} We also require that $msg \cap msgs' = \emptyset$. This implies that no duplicate messages will be generated.}

    Recall that, if $m(a,b)$ is a query operation, then $msgs' = \emptyset$.

    \item[-] Applying a message:

    $\begin{array}{l c} \bigfrac{ m = (\_,\_,r) \in msgs,Apl(repD[r],m) = d } {(repD,msgs,<_{sd}) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \},<_{sd}-m )} \end{array}$
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset)$.
\end{itemize}

We say that an execution of $\llbracket imp \rrbracket$ satisfies causal delivery, for each pair of update operations $(o_1,o_2)$, if $o_1 <_{hb} o_2$, let $(dat_1,r_1,\_)$ and $(dat_2,r_2,\_)$ be the message generated by $o_1$ and $o_2$, then for each replica $r$, the applying of $(dat_1,r_1,r)$ occurs before $(dat_2,r_2,r)$. The semantics of $imp$ with causal delivery is given as an LTS $\llbracket imp \rrbracket_{cd} = (Q_{cd},\Sigma,\rightarrow_{cd},q_{cd0})$, where

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $Q_{cd}$ is for the from $(repD,msgs,<)$, where $repD$ and $msgs$ is the same as that in $\llbracket imp \rrbracket$, and $< \subseteq (msgs \times msgs) \cup (msgs \times RId)$ is a transitive, acyclic and irreflexive relation. $<$ is used to record the happen-before relation between operations of messages. %$(m_1,m_2) \in <$ represents that the $op(m_1)$ happen before $op(m_2)$, while $(m,r) \in <$ represents that $op(m)$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.
    $(m_1,m_2) \in <$ represents that the operation generating $m_1$ happens before the operation generating $m_2$, while $(m,r) \in <$ represents that the operation generating $m$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.

\item[-] $\rightarrow_{cd}$ is the transition relation and contains three kinds of operations:

    The first kind is transitions of query operation. In this situation, messages and $<$ relations do not change:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,\emptyset)} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs,<)} \end{array}$



\item[-] The second kind is transitions of update operation :

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msgs' = \{ (dat,r,r') \vert r' \in RId \wedge r \neq r' \} \ for \ some \ dat} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',< \otimes dat)} \end{array}$

    Let us explain $< \otimes dat$. $< \otimes dat$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $\forall k' \in RId$, in $msgs(k')$, if $m_1 < r$, then erase $(m_1,r)$, add $(m_1,(dat,r,k'))$,

    \item[-] $\forall k' \in RId$, if $m_2$ is the maximal message among $\{ (\_,r,k') \}$ w.r.t $<$, then add $(m_2,(dat,r,k'))$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] The third kind is transitions of applying messages:

    $\begin{array}{l c} \bigfrac{ m = (dat,r_1,r) \in msgs,Apl(repD[r],m) = d, m \ is \ minimal \ w.r.t \ < among \ messages \ in \ msgs(r) } {(repD,msgs,<) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \}, < \otimes m )} \end{array}$

    Let us explain $< \otimes m$. $< \otimes m$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] First, remove $m$ from $<$ while keep orders of other elements in $<$ unchanged.

    \item[-] Then, $\forall k' \neq r$, if $(dat,r_1,k') \in msgs(k')$, then add $((dat,r_1,k'),k')$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset,\emptyset)$.
\end{itemize}

The following lemma states that, $\llbracket imp \rrbracket_{cd}$ contains the set of causal delivery executions of $\llbracket imp \rrbracket$. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section implementation}.

\begin{lemma}
\label{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}

$\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.
\end{lemma}
}
