%!TEX root = draft.tex

\section{Reference Implementation}
\label{sec:reference implementation}

%In this section, we propose an abstract implementation called reference implementation, which will be used as specification in simulation proof of later section.

An labeled transition system (LTS, for short) is a tuple $A = (Q,\Sigma,\rightarrow,q_0)$, where $Q$ is a set of states, $\Sigma$ is an alphabet of transition labels, $\rightarrow \subseteq Q \times \Sigma \times Q$ is a transition relation and $q_0$ is the initial state. A execution of $A$ is a sequences of transitions and states starting from the initial state $q_0$, and a trace is a sequence of transition labels of an execution. We say that $A$ is deterministic, if for each state $q$ and each transition label $\alpha$, $q$ has at most one $\rightarrow$ successor with transition label $\alpha$. 


\begin{figure}[t]
  \centering
  \includegraphics[width=0.8 \textwidth]{figures/PIC-RImp.pdf}
%\vspace{-10pt}
  \caption{Reference implementation for OR-set. Arrow of same replica represents $\mathit{ro}$ relation, while arrow between different replica represents $\mathit{del}$ relation.}
  \label{fig:reference implementation for OR-set}
\end{figure}

{\color {red}Let us use the example of \figurename~\ref{fig:reference implementation for OR-set} to explain how to model specification $\mathit{Spec}$ as a deterministic LTS $\mathit{RImp}(\mathit{Spec})$. 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $\mathit{Spec}$ is an annotated history. Since CRDT normally does not use speculative execution, the annotated history increase monotonously during transitions of $\mathit{Spec}$. For simplicity these annotated history only contains update operations. We introduce a new relation $\mathit{del}$ called delivery relation to capture the intuition that CRDT only broadcast effect of one operation.
    
    In $q_1$ of \figurename~\ref{fig:reference implementation for OR-set}, $(+a,r_2) \in \mathit{del}$ represents that the effect of $+a$ is delivered to replica $r_2$ after all operations of $r_2$ ($+b$ and $+c$) happens. While in $q_1$ of \figurename~\ref{fig:reference implementation for OR-set}, $(+a,-a_2) \in \mathit{del}$ represents that the effect of $+a$ is delivered to replica $r_2$ at a time point earlier than $-a_2$ happens and later than $+b$ and $+c$ happens. The visibility relation $\mathit{vis}$ of annotated history is defined as the composition of composition zero or one time of $\mathit{del}$ and $\mathit{ro}$.

\item[-] To do a $\ell$ operation on replica $r$, we check whether the operation context of the newest time-point of replica $r$ is in $\mathit{Spec}(\ell)$. If $\ell$ is query, then we have a loop transition, as the self-loop of $q_2$ in \figurename~\ref{fig:reference implementation for OR-set}; if $\ell$ is update, we increasing the annotated history by put a $\ell$ operation in the newest time-point of replica $r$, as the transition from $q_1$ to $q_2$ in \figurename~\ref{fig:reference implementation for OR-set}. 

\item[-] To make LTS be deterministic, we make the event of when a operation becomes visible to a replica also transition label. For example, the transition from $q_2$ to $q_3$ in \figurename~\ref{fig:reference implementation for OR-set} represents that $+c$ is visible to replica $r_1$. Thus, every change to visibility relation is explicitly. 
\end{itemize} }

Formally, the reference implementation $\mathit{RImp}(\mathit{Spec}) = (Q,\Sigma,\rightarrow,q_0)$ is constructed as follows: 

%\todo{Again, what is the purpose of $\mathit{li}$ and $correct$ ? The implementation should be a transition system like in the first section. No additional elements in the tuples.}

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] {\color {red}Each state $(O,\mathit{ro},\mathit{del},\mathit{arb}) \in Q$ contains four tuples: $O$ is a set of update operations, $\mathit{ro}$ is the replica order, $\mathit{del} \subseteq (O \times O) \cup (O \times \mathbb{R})$ is the delivery order, and $\mathit{arb}$ is the arbitration order.} 

%Each state of $Q$ records the set of updates already executed, when they were delivered to the different replicas, and the arbitration order.

    %Each state $(O,\mathit{ro},\mathit{del},\mathit{arb}) \in Q$ contains four tuples: $O$ is a set of update operations where each operation in $O$ has unique operation identifier; $\mathit{ro}$ is the replica order and $(O,\mathit{ro})$ a history; $\mathit{del} \subseteq (O \times O) \cup (O \times \mathbb{R})$ is a relation that records operation delivery and is called deliver order. {\color {red}Assume $o_2$ happens in replica $r_2$. $(o_1,o_2) \in \mathit{del}$ represents that the time point of delivering the effect of $o_1$ to replica $r_2$ is after all operations of replica $r_2$ that happens earlier than $o_2$, and before the time point  $o_2$ happens}. $(o,r) \in \mathit{del}$ represents that the effect of $o$ is delivered to replica $r$ after the time point of the last operation of replica $r$. we require $\mathit{del}$ to only relate operations with different replica identifier; $\mathit{arb} \subseteq O \times O$ is the arbitration order.
%\todo{$vis$ shouldn't be in the state.}

%\item[-] $\Sigma$ contains two kinds of transition labels: The first is operation labels tagged with replica identifier and arbitration order, in the form $(m,a,b,r,\mathit{arb})$, where $m \in \mathbb{M}, a,b \in \mathbb{D}, r \in \mathbb{R}$, and $arb \subseteq O \times O$; The second kind is events representing the points in time where operations are delivered, in the form $addDel(o,r)$, where $o \in \mathbb{O}, r \in \mathbb{R}$.


%\item[-] $\Sigma$ contains two kinds of transition labels: The first is operation labels tagged with replica identifier and modification of arbitration order, in the form $(m,a,b,r,ind)$, where $m \in \mathbb{M}, a,b \in \mathbb{D}, r \in \mathbb{R}$, and $ind \in \mathbb{N}$. Here $ind = 0$ means that the arbitration order does not change, while $ind >0$ means that the arbitration order is changed by inserting the newly generated operations into $ind$-th position; The second kind is events representing the points in time where operations are delivered, in the form $addDel(o,r)$, where $o \in \mathbb{O}, r \in \mathbb{R}$.

\item[-] {\color {red}$\Sigma$ contains two kinds of transition labels: $m(a,b,r,\mathit{arb})$ represents that a $m(a) \Rightarrow b$ operation is done in replica $r$ and the arbitration order is changed into $\mathit{arb}$. The reason of using $\mathit{arb}$ is also to make $\mathit{RImp}(\mathit{Spec})$ deterministic; $\mathit{addDel}(o,r)$ represents that operation $o$ begins to be visible to replica $r$.}

%$\Sigma$ contains two kinds of transition labels: The first is operation labels tagged with replica identifier and arbitration order, in the form $(m,a,b,r,\mathit{arb})$, where $m \in \mathbb{M}, a,b \in \mathbb{D}, r \in \mathbb{R}$, and $\mathit{arb}$ is the arbitration order. The second kind is events representing the points in time where operations are delivered, in the form $addDel(o,r)$, where $o \in \mathbb{O}, r \in \mathbb{R}$.

\item[-] $\rightarrow \subseteq Q \times \Sigma \times Q$ is the transition relation. The transition rules of $\rightarrow$ can be found in \figurename~\ref{fig:transition rules of RImpSpec}, and related notions are defined as follows:


    \begin {itemize}
    \item[-] {\color {red}Let $\mathit{visTo}(O,r,\mathit{vis}) = \{ vis^{-1}(o') \vert o'=(\_,r,\_) \in O \} \cup (vis^{-1}(r))$ be the set of operations that are visible to replica $r$ at the newest time point of replica $r$. Here we require $\mathit{vis}$ to be acyclic and irreflexive, and $\mathit{vis}^{-1}$ to be finite.}
    
    %Let $\mathit{vis} = \mathit{del} \cdot \mathit{ro}$ be the visibility relation. We further require $\mathit{vis}$ to be acyclic and irreflexive, and $\mathit{vis}^{-1}$ to be finite. Let $visTo(O,r,\mathit{vis}) = \{ vis^{-1}(o') \vert o'=(\_,r,\_) \in O \} \cup (vis^{-1}(r))$ be the set of operations that are visible to newest time point of replica $r$ or some operations of replica $r$.

    \item[-] {\color {red}$f_{\mathit{ctxt}}$ is a function that generate possible operation contexts if $o$ is done. It needs to guess new arbitration relation if necessary:} Given $q = (O,\mathit{ro},\mathit{del},\mathit{arb})$ and $o=(\_,r,\_) \notin O$, $f_{\mathit{ctxt}}(q,o)$ returns a set of elements, while each of them is a operation context of $o$ in an annotated history $(O',\mathit{vis}',\mathit{arb}')$, where $O'$ is fixed to $\mathit{visTo}(O,r,\mathit{vis}) \cup \{ o \}$, $\mathit{vis}'$ is fixed to $\mathit{vis} \uparrow_{O'} \cup \{ (o',o) \vert (o',r) \in \mathit{vis} \}$, and $\mathit{arb}'$ is obtained from $\mathit{arb} \uparrow_{O'}$ by possibly insert update operation $o$ into some place. 

        %\begin{itemize}
        %\setlength{\itemsep}{0.5pt}
        %\item[-] $O' = visTo(O,r,\mathit{vis}) \cup \{ o \}$.

        %\item[-] $\mathit{vis'} = \mathit{vis} \uparrow_{(O' \times O')} \cup \{ (o',o) \vert (o',r) \in \mathit{vis} \}$.

        %\item[-] If $o$ is an update operation, then $\mathit{arb}'$ is obtained from $\mathit{arb} \uparrow_{(O' \times O')}$ by possibly adding relations between $O'$ and $\{ o \}$; Else, $\mathit{arb}' = \mathit{arb} \uparrow_{(O' \times O')}$.
        %\item[-] $\mathit{arb}'$ is obtained from $\mathit{arb} \uparrow_{(O' \times O')}$ by possibly insert update operation $o$ into some place.
        %\end{itemize}

    %\item[-] $f_{\mathit{ar}}(\mathit{arb},o)$ returns an arbitration order that is obtained from $\mathit{arb}$ by possibly adding relations between $O$ and $\{ o \}$.
    \item[-] {\color {red}$\mathit{rand}(\mathit{arb},o)$ randomly returns an arbitration order that is obtained from $\mathit{arb}$ by either do nothing or insert update $o$ into some place.}

    \item[-] $ro \oplus o = ro \cup \{ (o',o) \vert o' = (\_,r,\_) \in O \}$. $del \oplus o$ returns a new delivery order obtained from $del$ by transforming each $(o',r)$ into $(o',o)$. 

    %\item[-] $pos(l,a)$ returns the position of $a$ in list $l$.
    \end{itemize}
    
    {\color {red}Note that the arbitration order may be changed only when new operation happens, while delivery does not change arbitration order.}  

\item[-] $q_0=(\emptyset,\emptyset,\emptyset,\emptyset)$ is the initial state.
\end{itemize}

\begin{figure}[ht]

\[
\begin{array}{l c}
\bigfrac{ o \in O, (o,r)\notin visTo(O,r,\mathit{vis}) }
{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{addDel(o,r)}} (O,\mathit{ro},\mathit{del} \cup \{ (o,r) \},\mathit{arb}) } %{\mathit{Delivery}}
\end{array}
\]


%\[
%\begin{array}{l c}
%\bigfrac{ o=(\ell,r,\_) \notin O, \exists x, x \in f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o) \wedge x \in Spec(\ell) }
%{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{m(a,b,r,\mathit{arb})}} (O,\mathit{ro},\mathit{del},\mathit{arb}) } {\mathit{Query}}
%\end{array}
%\]

\[
\begin{array}{l c}
\bigfrac{ m \in \mathbb{Q}, \ell = m(a) \Rightarrow b, o=(\ell,r,\_) \notin O, \exists x, x \in f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o) \wedge x \in Spec(\ell) }
{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{m(a,b,r,\mathit{arb})}} (O,\mathit{ro},\mathit{del},\mathit{arb}) } %{\mathit{Query}}
\end{array}
\]


%\[
%\begin{array}{l c}
%\bigfrac{ o = (\ell,r,\_) \notin O, \exists x, x = (O',\_,f_{\mathit{ar}}(\mathit{arb},o) \uparrow_{O'} ) \in f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o) \wedge x \in %Spec(\ell) }
%{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{m(a,b,r,f_{\mathit{ar}}(\mathit{arb},o))}} (O \cup \{ o \},\mathit{ro} \oplus o ,\mathit{del} \oplus %o,f_{\mathit{ar}}(\mathit{arb},o)) } {\mathit{Update}}
%\end{array}
%\]

\[
\begin{array}{l c}
\bigfrac{ m \in \mathbb{U}, \ell = m(a) \Rightarrow b, o = (\ell,r,\_) \notin O, \exists y=\mathit{rand}(\mathit{arb},o), \exists x = (O',\_,y \uparrow_{O'} ) \in f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o) \wedge x \in Spec(\ell) }
{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{m(a,b,r,y)}} (O \cup \{ o \},\mathit{ro} \oplus o ,\mathit{del} \oplus o,y) } %{\mathit{Update}}
\end{array}
\]

\caption{Transition rules of $\rightarrow$}
\label{fig:transition rules of RImpSpec}
\end{figure}

%\FloatBarrier

\noindent {\bf Example 3}:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] {\color {red}For OR-set, $f_{\mathit{ctxt}}$ and $\mathit{rand}(\mathit{arb},o)$ uses only arbitration order $\emptyset$.} 

\item[-] For distributed list: In $f_{\mathit{ctxt}}$, $\mathit{arb}'$ is obtained from $\mathit{arb} \uparrow_{O'}$ by inserting $o$ into some place if $o$ is a $add$ operation, or unchanged otherwise. $\mathit{rand}(\mathit{arb},o)$ returns an arbitration order that is obtained from $\mathit{arb}$ by insert $o$ into some place if $o$ is a $add$ operation, or unchanged otherwise.
\end{itemize}


We further require that when a new operation is generated, its candidate operation identifier is unique. Therefore, it is obvious that $\mathit{RImp}(\mathit{Spec})$ is deterministic. {\color {red}Given a execution $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots$ of $\mathit{RImp}(\mathit{Spec})$, its annotated history $(O,\mathit{vis},\mathit{arb})$ can be easily obtained: $O$ is the set of operations generated during execution; $\mathit{vis}$ can be applied from replica order and delivery; we can safely choose $\mathit{arb}$ to be the union of arbitration order of each $q_i$, since we construct arbitration order in a way where later-add operations does not influence earlier execution. With this annotated history, we can prove that the corresponding history is CRVC w.r.t $\mathit{Spec}$. Let $\mathit{his}(\mathit{RImp}(\mathit{Spec}))$ be the set of histories of $\mathit{RImp}(\mathit{Spec})$. The following theorem states that each history of $\mathit{his}(\mathit{RImp}(\mathit{Spec}))$ is CRVC consistent w.r.t $\mathit{Spec}$.} Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section reference implementation}.

\begin{theorem}
\label{theorem:histories of reference implementation are SRV consistent}
For each $h \in \mathit{his}(\mathit{RImp}(\mathit{Spec}))$, $h$ is CRVC consistent w.r.t $\mathit{Spec}$. 
\end{theorem}


\noindent {\bf Reference Implementation with Causal Delivery}:

An operation $o_1$ happens-before \cite{Lamport:1978} an operation $o_2$, denoted $o_1 <_{\mathit{hb}} o_2$, if $(o_1,o_2) \in (\mathit{ro},\mathit{del})^*$. A trace satisfies causal delivery, if for each pair of update operations $(o_1,o_2)$ of this trace and $o_1 <_{\mathit{hb}} o_2$, $o_2$ can be delivered to replica $r$ if $o_1$ has already been delivered to replica $r$. {\color {red}For example, the execution of \figurename~\ref{fig:reference implementation for OR-set} does not satisfy causal-delivery, since in $+b <_{\mathit{hb}} +c$, but when $+c$ is delivered to replica $r_1$, $+b$ is still not delivered to replica $r_1$.} 

To abstract CRDT implementations that assume causal delivery, we use a class of reference implementations $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$ where operations are delivered in the causal order. Formally, this consists in strengthening the transition rule corresponding to delivery events as follows:

%The reference implementation with causal delivery of $Spec$ is given as an LTS $RImp(Spec)_{\mathit{cd}} = (Q,\Sigma,q_0,\rightarrow)$. $RImp_{\mathit{cd}}(Spec)$ can be obtained from $RImp(Spec)$ by only changing the transition rules of delivery into the following:

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\begin{array}{l c} \bigfrac{o \in O, o \ is \ minimal \ w.r.t \ <_{\mathit{hb}} in \ \{ o' \vert o' \in O \wedge o' \notin \mathit{visTo}(O,r,\mathit{vis}) \}} {(O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{addDel(o,r)}} (O,\mathit{ro},\mathit{del} \cup \{ (o,r) \},\mathit{arb})} \end{array}$
\end{itemize}

%The following lemma states that $RImp(Spec)_{\mathit{cd}}$ contains all the traces of $RImp(Spec)$ that are causal delivery. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section reference implementation}.

%\begin{lemma}
%\label{lemma:RImpcdSpec contains all the sequences of RImpSpec that are causal delivery}
%$\llbracket RImp(Spec)_{\mathit{cd}} \rrbracket = \{ t \vert t \in \llbracket RImp(Spec) \rrbracket \wedge t$ satisfies causal delivery $\}$.
%\end{lemma}




\forget{
\noindent {\bf Example 3. $RImp(S_{\mathit{ORS}})$}: function $ctxt$ and predicate $cor$ are defined as follows:
\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Given $o=(\_,r,\_)$ and $q=(O,ro,del,\emptyset)$, $ctxt(q,o) = (visTo(O,r,vis),<_1,\emptyset)$, where $<_1 = vis \uparrow_{(O_1 \times O_1)} - \{ (o_1,o_2) \vert o_2 \notin Minus(q,o_1), \exists o_3, o_1 {\xrightarrow{vis}} o_3 {\xrightarrow{vis}} o_2, o_1,o_2 \in visTo(O,r,vis), o_3 \notin visTo(O,r,vis) \}$.

Here $Minus(q,o_1)$ is defined as follows: (1) if $lab(o_1)=add(a)$, then $Minus(q,o_1) = \{o_2 \vert lab(o_2)=rem(a), o_1 {\xrightarrow{vis}} o_2, \neg \exists o_3, ( lab(o_3) = rem(a) ) \wedge ( o_1 {\xrightarrow{vis}} o_3 {\xrightarrow{vis}} o_2 ) \}$, (2) otherwise, $Minus(q,o_1) = \emptyset$.

\item[-] $cor((O,ro,del,arb))$ holds, if

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $arb= \emptyset$.

    \item[-] $\forall o \in O$, if $lab(o)=rem(a)$, then $\exists o', o \in Minus(q,o')$.
    \end{itemize}
\end{itemize}

\noindent {\bf Example 4. $RImp(S_{\mathit{list}})$}: function $ctxt$ and predicate $cor$ are defined as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Given $q = (O,ro,del,arb)$ and $o =(\_,r,\_)$, $ctxt(q,o) = ( O_1 ,<_1, arb_1 )$, where $O_1 = visTo(O,r,vis)$, $<_1 = vis \uparrow_{(O_1 \times O_1)}$, and $arb_1$ is as follows: (1) if $lab(o)=add(\_)$, then $arb_1$ is a total order generated by adding $o$ into some place of $arb$, (2) otherwise, $arb_1 = arb$. We also require that

\item[-] $cor((O,ro,del,arb))$ holds, if

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $arb$ is a acyclic and irreflexive total order over $add$ operations of $O$.

    \item[-] For each operation $o \in O$, $f(o) \neq \mathit{Undef}$.
    \end{itemize}
\end{itemize}
}

















