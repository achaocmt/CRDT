%!TEX root = draft.tex

\section{Implementation}
\label{sec:implementation}

Let $\mathbb{L}$ be the set of local state for a replica, and $\mathbb{MSG}$ be the set of messages. Each message is of the form $(d,r_s,r_d)$ where $r_s \in \mathbb{R}$ is the identifier of replica that generates this message, and $r_d \in \mathbb{R}$ is the destination replica identifier of this message.

A CRDT implementation $imp$ is defined as a tuple {\color {red}$(\rightarrow_o,\rightarrow_m,d_0,f_{\mathit{arb}}, \Sigma_e)$, where
%$(f_M,f_{apl},d_{\mathit{init}},f_{o},f_{arb})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\rightarrow_o: \mathbb{L} \times \mathbb{M} \times \mathbb{D} \times \mathbb{R} \rightarrow \mathbb{L} \times \mathbb{D} \times Pow(\mathbb{MSG})$ shows how method update local state and generate messages. $(d,m,a,r) \rightarrow_o (d',b,msgs)$ means that, when the local state of replica $r$ is $d$, if we call method $m$ with argument $a$ in replica $r$, then we obtain return value $b$, change the local state of replica $r$ into $d'$, and generate a set $msgs$ of messages. $Pow(\mathbb{MSG})$ means the power set of $\mathbb{MSG}$. Moreover, if $m \in \mathbb{I}$, then $msgs = \{ (x,r,r') \vert r' \in \mathbb{R} \wedge r \neq r' \}$ for some $x$. Otherwise, $msgs = \emptyset$.

\item[-] $\rightarrow_m: \mathbb{L} \times \mathbb{R} \times \mathbb{MSG} \rightarrow \mathbb{L}$. $(d,r,msg) \rightarrow_m d'$ means that, if the local state of replica $r$ is $d$ and we apply message $msg$, then we obtain local state $d'$.

\item[-] $d_0 \in \mathbb{L}$ is the initial local state.

\item[-] $f_{\mathit{arb}}$ takes several local states and a set of messages as arguments, and returns a total order over elements, while each element represents an operation. To do this, we need a method to extract elements from local states and messages. Let the set of extracted elements to be $\Sigma_e$.

%\item[-] $f_{o}: \Sigma_{\mathtt{RD}}^{\vert \mathbb{R} \vert} \times Pow(\mathbb{MSG}) \Rightarrow Pow(\Sigma_o)$, where $\Sigma_o$ is a set of elements and each element represents an operation. Given replica data of each replica, $f_{o}$ is used to obtain the ``operations'' known by current state of implementation.

%\item[-] $f_{arb}: \Sigma_{\mathtt{RD}}^{\vert \mathbb{R} \vert} \times Pow(\mathbb{MSG}) \Rightarrow \Sigma_o^*$. Given replica data of each replica and messages, $f_{arb}$ is used to obtain the arbitration relation.
\end{itemize}
}

The semantics of $imp$ is given as an LTS $Sem(imp) = (Q,\Sigma,\rightarrow,q_0)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state $(data,msgs) \in Q$ contains two tuples: $data: \mathbb{R} \rightarrow \mathbb{L}$ is the local state each replica, $msgs \subseteq \mathbb{MSG}$ is the set of messages.

\item[-] {\color {red}$\Sigma = \{ (m,a,b,r,\mathit{arb}), apply(msg) \vert m \in \mathbb{M}, a,b \in \mathbb{D}, r \in \mathbb{R}, msg \in \mathbb{MSG},\mathit{arb} \subseteq \Sigma_e \times \Sigma_e \}$ is the set of transition labels. Here $\mathit{arb}$ is a irreflexive total order over a subset of update operations $\Sigma_e$.}

\item[-] $\rightarrow$ is the transition relation and is defined as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] %Doing an operation:

    $\begin{array}{l c} \bigfrac{ (data[r],m,a,r) \rightarrow_o (d,b,msgs'), msg \cap msgs' = \emptyset, f_{\mathit{arb}}((data[r:d], msgs \cup msgs')) = \mathit{arb}} {(data,msgs) {\xrightarrow{(m,a,b,r,\mathit{arb})}} (data[r:d],msgs \cup msgs')} \end{array}$

    \item[-] %Applying a message:

    $\begin{array}{l c} \bigfrac{ m = (\_,\_,r) \in msgs,(data[r],r,m) \rightarrow_m d } {(data,msgs) {\xrightarrow{apply(m)}} (data[r:d],msgs - \{ m \}} \end{array}$
    \end{itemize}

\item[-] $q_0 = (data_0,\emptyset)$ is the initial state, where $data_0$ maps each replica identifier into $d_0$.
\end{itemize}

An trace of implementation satisfies causal-delivery, if given $o_1 <_{\mathit{hb}} o_2$, then we can apply message generated by $o_2$ on a replica, if the message generated by $o_1$ has already been applied on this replica. The semantics of $imp$ with causal delivery is given as an LTS $OS(imp)_{\mathit{cd}}$, and we give its detailed definition in Appendix \ref{sec:appendix definitions and proofs of section implementation}. Each state of $OS(imp)_{\mathit{cd}}$ is a tuple $(data,msgs,\mathit{hb})$, while $\mathit{hb}$ record the happen-before relation between messages with same destination replica.




\noindent {\bf Example 6. OR-set algorithms of \cite{Shapiro:2011}}: The OR-set algorithms of \cite{Shapiro:2011} is defined as a tuple $(\rightarrow_o,\rightarrow_m,d_0,\rightarrow_{\mathit{arb}}, \Sigma_e)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathbb{L} = \{ (S,ctr) \vert S \subseteq \mathbb{D} \times (\mathbb{R} \times \mathbb{N}), ctr \in \mathbb{N} \}$. Each element of $\mathbb{L}$ is of the form $(a,id)$, and $ctr$ is per-replica counter to make $id$ unique.

\item[-] $((S,ctr),add,a,r) \rightarrow_o ((S',ctr+1),msgs)$, where $S'=S \cup \{ (a,id) \}$, and $msgs = \{ (a,id,r,r') \vert r' \neq r \}$, where $id = (r,ctr)$.

\item[-] $((S,ctr),rem,a,r) \rightarrow_o ((S',ctr),msgs)$, where $S'=S \setminus \{ (a,id) \in S \}$, $msgs = \{ (a,S'',r,r') \vert r' \neq r \} $, $S'' = \{ id \vert (a,id) \in S \}$ and we require that $S'' \neq \emptyset$.

\item[-] $((S,ctr),lookup,a,r) \rightarrow_o ((S,ctr),\mathit{true},\emptyset)$, if there exists $id$, such that $(a,id) \in S$.

\item[-] $((S,ctr),lookup,a,r) \rightarrow_o ((S,ctr),\mathit{false},\emptyset)$, if for each $id$, we have $(a,id) \notin S$.

\item[-] Given $m=(a,id,\_,r)$, $((S,ctr),r,m) \rightarrow_m (S \cup \{ (a,id) \},ctr)$.

\item[-] Given $m=(a,S',\_,r)$, $((S,ctr),r,m) \rightarrow_m (S \setminus \{ (a,id) \vert id \in S' \},ctr)$.

\item[-] $d_0 = (\emptyset,0)$.

\item[-] $\Sigma_e$ is the union of (1) the set of $(a,id)$ for $(a,id) \in S$ or $(a,S',\_,\_)$ in messages and $id \in S'$, and (2) the set of $(a,S,r)$ when $(a,S,r,\_)$ is in messages.

\item[-] $f_{arb}$ always return $\emptyset$.
\end{itemize}


\noindent {\bf Example 7. woot algorithms of \cite{Oster:2006}}: Let us introduce the woot algorithm. A W-character $x$ is a five-tuple $(id,a,v,id_p,id_n)$, where $id$ is the identifier of $x$; $a$ is the value of $x$; $v \in \{ \mathit{true},\mathit{false} \}$ indicates whether $x$ is visible or tombstone; $id_p$ and $id_n$ are the identifier of previous and next W-character of $x$, while each W-character is generated to be inserted in between $id_p$ and $id_n$. Here $id=(r,c)$ where $r \in \mathbb{R}$ and $c \in \mathbb{N}$.

$\mathbb{L} = \{ (ctr, str) \vert ctr \in \mathbb{N}, str$ is a string of W-character $\}$. $str$ is the list seen by this replica, and $ctr$ is per-replica counter to make unique identifier. Let $<_{\mathit{ts}}$ be the order of time stamp, such that $(r_1,c_1) <_{\mathit{ts}} (r_2,c_2)$, if $(c_1 < c_2) \vee (c_1 = c_2 \wedge r_1 < r_2)$. Given a sequence $s$, let $<_s$ be order of $x$, such that $a <_s b$, if they are both in $s$ and a has smaller index.

Let us explain $\rightarrow_o$ for each methods of woot:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-]  If there exists $y \in str$, such that $y = (\_,x,\mathit{true},\_,\_)$, then we have $((ctr,str),rem,x,r) \rightarrow_o ((ctr,str'),msgs)$, where $str'$ is obtained from $str$ by changing the flag of $y$ into $\mathit{false}$, and $msgs = \{ (y,r,r') \vert r' \neq r \}$; Else, $((ctr,str),rem,x,r) \rightarrow_o \mathit{undef}$.

\item[-] $((ctr,str),read,r) \rightarrow_o ((ctr,str),l,\emptyset)$, where $l$ is the sequence of values of elements in $str$ with flag $\mathit{true}$.

\item[-] $((ctr,str),add,x,pos,r) \rightarrow_o ((ctr+1,str'),msgs)$: Assume $str[pos]=b$ and $str[pos+1]=c$, let $y = ((r,ctr),x,\mathit{true},b.id,c.id)$, then $msgs = \{ (y,b,c,r,r') \vert r' \neq r \}$, and $str' = \mathit{insert}(y,b,c)$ for recursive function $\mathit{insert}$ defined in Algorithm \ref{alg:insert}. Notions of Algorithm \ref{alg:insert} are as follows: Given $d_u = (id,a,v,id_p,id_n)$, $pre(d_u) = id_p$ and $next(d_u)=id_n$; $subseq(str,c_p,c_n)$ returns the sub-sequence of $str$ between $c_p$ and $c_n$; $pos(str,c_n)$ returns the position of $c_n$ in $str$; $ins(str,c,pos)$ inserts $c$ into $str$ at position $pos$.
\end{itemize}


\begin{algorithm}[t]
\KwIn {$c$, $c_p$, $c_n$}
\KwOut{a W-character string}

Let $str' = subseq(str,c_p,c_n)$ \;

\If {$str' = \epsilon$}
{
    \Return $ins(str,c,pos(str,c_n))$\;
}
\Else
{
    let $L = c_p \cdot d_0 \cdot \ldots \cdot d_k \cdot c_n$, where $d_0,\ldots,d_k$ are the W-char in $str'$ such that $pre(d_u) \leq_{str} c_p$ and $c_n \leq_{str} next(d_u)$\;
    let $j = 1$\;
    {\bf while} $(j < \vert L \vert -1 \wedge L[j] <_{\mathit{ts}} c)$\ {\bf do}
    {
        $j = j+1$\;
    }
    return $\mathit{insert}(c,L[i-1],L[i])$\;
}
\caption{$\mathit{insert}$}
\label{alg:insert}
\end{algorithm}

The other part of woot is defined as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\rightarrow_m$:
    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Given $m=((\_,a,\_,\_,\_),\_,r)$: If $str$ contains element $y$ that has value $a$ and flag $\mathit{true}$, then we have $((ctr,str),r,m) \rightarrow_m (ctr,str')$, where $str'$ is obtained from $str$ by changing the flag of $y$ into $\mathit{false}$.

    \item[-] Given $m=(x,y,z,\_,r)$: If $str$ contains $y$ and $z$, then we have $((ctr,str),r,m) \rightarrow_m (ctr,str')$, where $str' = \mathit{insert}(x,y,z)$.
    \end{itemize}

\item[-] $d_0 = (0,\epsilon)$.

\item[-] $\Sigma_e$ is the union of (1) the set of $a$ for values in local states and messages, and (2) the set of $(x,y,z)$ in messages. 

\item[-] $f_{arb}$ orders $x$ and $y$ as follows: Given $x = (id,a,v,id_p,id_n)$, we say that $x$ relies on W-character with identifiers $id_p$ and $id_n$. We say that $(x,y) \in f_{arb}$, if one of the following cases holds: (1) there exists $z_1,\ldots,z_k$, such that $x=z_1$, $y=z_k$, and for each $u$, $next(z_u)=z_{u+1} \vee pre(z_{u+1}) = z_u$. (2) Starting from $\epsilon$, we put all elements that $y$ and $z$ rely, then we put $y$ and $z$, and find that $y$ is before $z$ in $str$ of the resulting local state. 
\end{itemize}


















\forget{
\section{Implementation}
\label{sec:implementation}

Let $\mathbb{RD}$ be the set of data of replica. Let $\mathbb{MSG}$ be the set of messages. Each message is of the from $msg=(dat,sorR,desR)$ and is generated when some replica does an operation. Here $dat \in \mathbb{RD}$ is the information carried by message, $sorR,desR \in \mathbb{R}$ are the replica identifier of the replica that launched the message and the destination replica of this message, respectively.

A CRDT implementation $imp$ is defined as a tuple $(Mth,Apl,Pred,InitD)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $Mth: \mathbb{M} \times \mathbb{D} \times \mathbb{RD} \times \mathbb{R} \rightarrow \mathbb{D} \times \mathbb{RD} \times Pow(\mathbb{MSG})$. $Mth(m,a,d,r) = (b,ar,d',msgs)$ means that, if the data of replica $r$ is $d$, then if we call method $m$ with argument $a$ in replica $r$, then we obtain return value $b$ and change the data of replica $r$ into $d'$, and generate a set $msgs$ of messages. Here $Sub(\mathbb{RD})$ means we only return a part

    Here if $m$ is an update method, then $msgs = \{ (dat,r,r') \vert r' \in \mathbb{R} \wedge r \neq r' \}$ for some $dat$. Otherwise, if $m(a,b)$ is a query operation, then $msgs = \emptyset$.

\item[-] $Apl: \mathbb{RD} \times \mathbb{MSG} \rightarrow \mathbb{RD}$. $Apl(d,msg) = d'$ means that, if the current replica data is $d$ and we apply message $msg$, then we obtain replica data $d'$.

\item[-] $Pred: (\mathbb{M} \times \mathbb{D} \times \mathbb{RD} \rightarrow \{ \mathit{true},\mathit{false} \}) \cup (\mathbb{RD} \times \mathbb{MSG} \rightarrow \{ \mathit{true},\mathit{false} \})$ is used to check whether a method can proceed, or whether a message can be applied.

\item[-] $InitD \in \mathbb{RD}$ is the initial replica data.
\end{itemize}

The semantics of $imp$ is given as an LTS $\llbracket imp \rrbracket = (Q,\Sigma,\rightarrow,q_0)$ \footnote{{\color {red} For some implementations, more information may be used as tuple of state of $\llbracket imp \rrbracket$. Such information are only for make transition labels clear and do not influence execution. For example, for distributed list algorithm, the order of all known items may be used as a argument. Similarly, we may add more information into transition labels when it is necessary.}}, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state $(repD,msgs,<_{sd}) \in Q$ contains three tuples. Here $repD: RId \rightarrow RepD$ is the replica data of each replica, $msgs \subseteq Msg$ is the set of messages, $<_{sd} \subseteq Meg \times Msg$ is used to record the order of messages. $<_{sd}$ only relates messages with the same source replica identifier and with the same destination replica identifier.

Let $msgs(r,r') = \{ (\_,r,r') \in msgs \}$ denote the set of messages in $msgs$ whose source replica is $r$ and whose destination replica is $r'$. $\forall r,r' \in RId$, $<_{sd}$ is a irreflexive and acyclic total order on $msgs(r,r')$. %We also require that the transitive closure of $<_{ro}$ on operations being acyclic.
The reason we introduce $<_{sd}$ into state is for defining simulation relation in the next section.

\item[-] $\Sigma = \{ m(a,b,r), apply(msg) \vert m \in M, a,b \in D, r \in RId, msg \in Msg \}$ is the set of transition labels.

\item[-] $\rightarrow$ is the transition relation and is defined as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Doing an operation:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msg \cap msgs' = \emptyset} {(repD,msgs,<_{sd}) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',<_{sd} \odot msgs')} \end{array}$

    Here $<_{sd} \odot msgs'$ is obtained from $<_{sd}$ by adding  $(m_1,m_2)$, when $m_1 \in msgs$, $m_2 \in msgs'$, the souce replica of $m_1$ is the same as that of $m_2$, and the desitination replica of $m_1$ is the same as that of $m_2$. {\color {red} We also require that $msg \cap msgs' = \emptyset$. This implies that no duplicate messages will be generated.}

    Recall that, if $m(a,b)$ is a query operation, then $msgs' = \emptyset$.

    \item[-] Applying a message:

    $\begin{array}{l c} \bigfrac{ m = (\_,\_,r) \in msgs,Apl(repD[r],m) = d } {(repD,msgs,<_{sd}) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \},<_{sd}-m )} \end{array}$
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset)$.
\end{itemize}

We say that an execution of $\llbracket imp \rrbracket$ satisfies causal delivery, for each pair of update operations $(o_1,o_2)$, if $o_1 <_{hb} o_2$, let $(dat_1,r_1,\_)$ and $(dat_2,r_2,\_)$ be the message generated by $o_1$ and $o_2$, then for each replica $r$, the applying of $(dat_1,r_1,r)$ occurs before $(dat_2,r_2,r)$. The semantics of $imp$ with causal delivery is given as an LTS $\llbracket imp \rrbracket_{cd} = (Q_{cd},\Sigma,\rightarrow_{cd},q_{cd0})$, where

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $Q_{cd}$ is for the from $(repD,msgs,<)$, where $repD$ and $msgs$ is the same as that in $\llbracket imp \rrbracket$, and $< \subseteq (msgs \times msgs) \cup (msgs \times RId)$ is a transitive, acyclic and irreflexive relation. $<$ is used to record the happen-before relation between operations of messages. %$(m_1,m_2) \in <$ represents that the $op(m_1)$ happen before $op(m_2)$, while $(m,r) \in <$ represents that $op(m)$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.
    $(m_1,m_2) \in <$ represents that the operation generating $m_1$ happens before the operation generating $m_2$, while $(m,r) \in <$ represents that the operation generating $m$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.

\item[-] $\rightarrow_{cd}$ is the transition relation and contains three kinds of operations:

    The first kind is transitions of query operation. In this situation, messages and $<$ relations do not change:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,\emptyset)} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs,<)} \end{array}$



\item[-] The second kind is transitions of update operation :

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msgs' = \{ (dat,r,r') \vert r' \in RId \wedge r \neq r' \} \ for \ some \ dat} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',< \otimes dat)} \end{array}$

    Let us explain $< \otimes dat$. $< \otimes dat$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $\forall k' \in RId$, in $msgs(k')$, if $m_1 < r$, then erase $(m_1,r)$, add $(m_1,(dat,r,k'))$,

    \item[-] $\forall k' \in RId$, if $m_2$ is the maximal message among $\{ (\_,r,k') \}$ w.r.t $<$, then add $(m_2,(dat,r,k'))$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] The third kind is transitions of applying messages:

    $\begin{array}{l c} \bigfrac{ m = (dat,r_1,r) \in msgs,Apl(repD[r],m) = d, m \ is \ minimal \ w.r.t \ < among \ messages \ in \ msgs(r) } {(repD,msgs,<) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \}, < \otimes m )} \end{array}$

    Let us explain $< \otimes m$. $< \otimes m$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] First, remove $m$ from $<$ while keep orders of other elements in $<$ unchanged.

    \item[-] Then, $\forall k' \neq r$, if $(dat,r_1,k') \in msgs(k')$, then add $((dat,r_1,k'),k')$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset,\emptyset)$.
\end{itemize}

The following lemma states that, $\llbracket imp \rrbracket_{cd}$ contains the set of causal delivery executions of $\llbracket imp \rrbracket$. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section implementation}.

\begin{lemma}
\label{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}

$\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.
\end{lemma}
}





















\forget
{
In this section, we give our formation of CRDT algorithms (implementation) and their semantics.

In a CRDT algorithm, each replica stores a copy of shared data and possibly some auxiliary data. For example, in OR-set algorithm of \cite{Bieniusa:2012}, the shared data consists of a set $E$ of current item and a set $T$ of tombstone, and the auxiliary data is a counter used to ensure the uniqueness of item identifier.

Let $RepD$ be the set of data of replica. Let $Msg$ be the set of messages. Each message is of the from $msg=(dat,sorR,desR)$ and is generated since some replica does an operation. Here $dat$ is some information, %and we assume that we can use a function $op(dat)$ to obtain the operation that generates $msg$,
$sorR \in RId$ indicates that which replica launches this operation, and $desR \in RId$ indicates the destination replica identifier of this message. %Let $data(msg)=dat$ be a function that reads the data of a message.

Then a CRDT implementation $imp$ is defined as a tuple $(Mth,Apl,InitD)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $Mth: M \times D \times PRD \times RId \rightarrow D \times PRD \times Pow(Mes)$. $Mth(m,a,d,rid) = (b,d',msgs)$ means that, if the current replica data is $d$ and we call method $m$ with argument $a$ in replica $rid$, then the resulting replica data is $d'$, we obtain return value $b$, and generate a set $msgs$ of messages. Here we assume that if $m$ is an update method, then $msgs = \{ (dat,rid,r') \vert r' \in RId \wedge rid \neq r' \}$ for some $dat$. %where $op(dat)$ uses method $m$ with argument $a$ and return value $b$.

    We also assume that, if $m(a,b)$ is a query operation, then $msgs = \emptyset$.

\item[-] $Apl: RepD \times Msg \rightarrow RepD$. $Apl(d,msg) = d'$ means that, if the current replica data is $d$ and we apply message $msg$, then we obtain replica data $d'$.

\item[-] $InitD \in RepD$ is the initial replica data.
\end{itemize}

The semantics of $imp$ is given as an LTS $\llbracket imp \rrbracket = (Q,\Sigma,\rightarrow,q_0)$ \footnote{{\color {red} For some implementations, more information may be used as tuple of state of $\llbracket imp \rrbracket$. Such information are only for make transition labels clear and do not influence execution. For example, for distributed list algorithm, the order of all known items may be used as a argument. Similarly, we may add more information into transition labels when it is necessary.}}, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state $(repD,msgs,<_{sd}) \in Q$ contains three tuples. Here $repD: RId \rightarrow RepD$ is the replica data of each replica, $msgs \subseteq Msg$ is the set of messages, $<_{sd} \subseteq Meg \times Msg$ is used to record the order of messages. $<_{sd}$ only relates messages with the same source replica identifier and with the same destination replica identifier.

Let $msgs(r,r') = \{ (\_,r,r') \in msgs \}$ denote the set of messages in $msgs$ whose source replica is $r$ and whose destination replica is $r'$. $\forall r,r' \in RId$, $<_{sd}$ is a irreflexive and acyclic total order on $msgs(r,r')$. %We also require that the transitive closure of $<_{ro}$ on operations being acyclic.
The reason we introduce $<_{sd}$ into state is for defining simulation relation in the next section.

\item[-] $\Sigma = \{ m(a,b,r), apply(msg) \vert m \in M, a,b \in D, r \in RId, msg \in Msg \}$ is the set of transition labels.

\item[-] $\rightarrow$ is the transition relation and is defined as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Doing an operation:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msg \cap msgs' = \emptyset} {(repD,msgs,<_{sd}) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',<_{sd} \odot msgs')} \end{array}$

    Here $<_{sd} \odot msgs'$ is obtained from $<_{sd}$ by adding  $(m_1,m_2)$, when $m_1 \in msgs$, $m_2 \in msgs'$, the souce replica of $m_1$ is the same as that of $m_2$, and the desitination replica of $m_1$ is the same as that of $m_2$. {\color {red} We also require that $msg \cap msgs' = \emptyset$. This implies that no duplicate messages will be generated.}

    Recall that, if $m(a,b)$ is a query operation, then $msgs' = \emptyset$.

    \item[-] Applying a message:

    $\begin{array}{l c} \bigfrac{ m = (\_,\_,r) \in msgs,Apl(repD[r],m) = d } {(repD,msgs,<_{sd}) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \},<_{sd}-m )} \end{array}$
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset)$.
\end{itemize}

We say that an execution of $\llbracket imp \rrbracket$ satisfies causal delivery, for each pair of update operations $(o_1,o_2)$, if $o_1 <_{hb} o_2$, let $(dat_1,r_1,\_)$ and $(dat_2,r_2,\_)$ be the message generated by $o_1$ and $o_2$, then for each replica $r$, the applying of $(dat_1,r_1,r)$ occurs before $(dat_2,r_2,r)$. The semantics of $imp$ with causal delivery is given as an LTS $\llbracket imp \rrbracket_{cd} = (Q_{cd},\Sigma,\rightarrow_{cd},q_{cd0})$, where

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $Q_{cd}$ is for the from $(repD,msgs,<)$, where $repD$ and $msgs$ is the same as that in $\llbracket imp \rrbracket$, and $< \subseteq (msgs \times msgs) \cup (msgs \times RId)$ is a transitive, acyclic and irreflexive relation. $<$ is used to record the happen-before relation between operations of messages. %$(m_1,m_2) \in <$ represents that the $op(m_1)$ happen before $op(m_2)$, while $(m,r) \in <$ represents that $op(m)$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.
    $(m_1,m_2) \in <$ represents that the operation generating $m_1$ happens before the operation generating $m_2$, while $(m,r) \in <$ represents that the operation generating $m$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.

\item[-] $\rightarrow_{cd}$ is the transition relation and contains three kinds of operations:

    The first kind is transitions of query operation. In this situation, messages and $<$ relations do not change:

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,\emptyset)} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs,<)} \end{array}$



\item[-] The second kind is transitions of update operation :

    $\begin{array}{l c} \bigfrac{ Mth(m,a,repD[r]) = (b,d,msgs'), msgs' = \{ (dat,r,r') \vert r' \in RId \wedge r \neq r' \} \ for \ some \ dat} {(repD,msgs,<) {\xrightarrow{m(a,b,r)}} (repD[r:d],msgs \cup msgs',< \otimes dat)} \end{array}$

    Let us explain $< \otimes dat$. $< \otimes dat$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $\forall k' \in RId$, in $msgs(k')$, if $m_1 < r$, then erase $(m_1,r)$, add $(m_1,(dat,r,k'))$,

    \item[-] $\forall k' \in RId$, if $m_2$ is the maximal message among $\{ (\_,r,k') \}$ w.r.t $<$, then add $(m_2,(dat,r,k'))$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] The third kind is transitions of applying messages:

    $\begin{array}{l c} \bigfrac{ m = (dat,r_1,r) \in msgs,Apl(repD[r],m) = d, m \ is \ minimal \ w.r.t \ < among \ messages \ in \ msgs(r) } {(repD,msgs,<) {\xrightarrow{apply(m)}} (repD[r:d],msgs - \{ m \}, < \otimes m )} \end{array}$

    Let us explain $< \otimes m$. $< \otimes m$ will change $<$ as follows:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] First, remove $m$ from $<$ while keep orders of other elements in $<$ unchanged.

    \item[-] Then, $\forall k' \neq r$, if $(dat,r_1,k') \in msgs(k')$, then add $((dat,r_1,k'),k')$.

    \item[-] Make the transitive closure.
    \end{itemize}

\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset,\emptyset)$.
\end{itemize}

The following lemma states that, $\llbracket imp \rrbracket_{cd}$ contains the set of causal delivery executions of $\llbracket imp \rrbracket$. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section implementation}.

\begin{lemma}
\label{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}

$\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.
\end{lemma}
}
