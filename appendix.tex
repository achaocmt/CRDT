%!TEX root = draft.tex

\section{Definitions and Proofs of Section \ref{sec:reference implementation}}
\label{sec:appendix definitions and proofs of section reference implementation}

{\noindent \bf Theorem \ref{theorem:histories of reference implementation are SRV consistent}}: For each $h \in \mathit{his}(\mathit{RImp}(\mathit{Spec}))$, $h$ is CRVC consistent w.r.t $\mathit{Spec}$. 

\begin {proof} 

Assume $\mathit{RImp}(\mathit{Spec}) = (Q,\Sigma,\rightarrow,q_0)$. We prove this theorem by proving that, given a trace $t = \alpha_1 \cdot \ldots$ of $\mathit{RImp}(\mathit{Spec})$, its annotated history $\mathit{ah}_t$ is SRVC consistent w.r.t $\mathit{Spec}$. 

Let $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots$ be the execution of $t$. Let $\mathit{ah}_t = (O_t,\mathit{vis}_t,\mathit{arb}_t)$. According to the construction of $\mathit{ah}_t$, it is easy to see that $\mathit{ro}_t \subseteq \mathit{vis}_t \wedge \mathit{vis}_t$ is acyclic.

We need to prove that, there exists function $ctxt$, such that $\forall o \in O_t$, $ctxt(o) = (O_o,<_o,arb_o) \in Spec(lab(o))$. Assume $o$ is generated with the transition $q_k = (O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k)$ ${\xrightarrow{\alpha_{k+1}}} q_{k+1}$. It is easy to see that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $O_k$ is the set of update operations in $\alpha_1 \cdot \ldots \cdot \alpha_k$,

\item[-] $(\mathit{ro}_k \cup (\mathit{del}_k \cdot \mathit{ro}_k)) \uparrow_{ Q_k }$ is the visibility relation of update operations of $\alpha_1 \cdot \ldots \cdot \alpha_k$,

\item[-] $\mathit{arb}_k$ is the projection of $arb_t$ into $O_k \times O_k$.
\end{itemize}

By the definition of transition relation of $\mathit{RImp}(\mathit{Spec})$, we can always choose $ctxt(o)$ to be $f_{\mathit{ctxt}}((O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k),o)$. It is easy to see that $ctxt(o)$ to be $ctxt(o) = f_{\mathit{ctxt}}((O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k),o)$ holds as required. This completes the proof of this theorem. $\qed$
\end {proof}





Let $\mathit{trace}(A)$ be the set of traces of LTS $A$. The following lemma states that the trace of $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$ is the set of traces of $\mathit{RImp}(\mathit{Spec})$ that satisfies causal delivery. 

\begin{lemma}
\label{lemma:RImpcdSpec contains all the sequences of RImpSpec that are causal delivery}
$\mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} ) = \{ t \vert t \in \mathit{trace}( \mathit{RImp}(\mathit{Spec}) ) \wedge t$ satisfies causal delivery $\}$. 
\end{lemma} 

\begin {proof}

Let us prove the $\subseteq$ direction. We prove it by contradiction. Assume $\exists t =\alpha_1 \cdot \ldots \cdot \alpha_k \in \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$ and $t$ does not satisfy causal delivery. Then there exists operations $o_1,o_2$ and replica $r$, such that $(o_1,o_2) \in \mathit{hb}$ and in $t$, when $o_2$ is delivered to replica $r$, $o_1$ has not been delivered to replica $r$ yet.

Let $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots {\xrightarrow{\alpha_k}} q_k$ be the execution of $t$. Assume that for each $u$, $q_u = (O_u,\mathit{ro}_u,\mathit{del}_u,\mathit{arb}_u)$. It is easy to prove by induction that, for each $u$, when both $o_1$ and $o_2$ are in $O_u$, $(o_1,o_2) \in \mathit{vis}_u = (\mathit{ro}_u \cup \mathit{del}_u)^*$. Let $\alpha_v = \mathit{addDel}(o_2,r)$. Then, we can see that $(o_1,o_2) \in \mathit{vis}_{v-1} = (\mathit{ro}_{v-1} \cup \mathit{del}_{v-1})^*$, and $o_1,o_2 \notin \mathit{visTo}(O_{v-1},r,\mathit{vis}_{v-1})$. By our definition of transition relation of $\mathit{RImp}(\mathit{Spec})$, we could not launch $\mathit{addDel}(o_2,r)$ transition from $q_{u-1}$, contradiction happens. 

Let us prove the $\supseteq$ direction. We prove its contrapositive. Assume that $t_1 =\alpha_1 \cdot \ldots \cdot \alpha_k \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$, we need to prove that $t_1 \notin \{ t \vert t \in \mathit{trace}( \mathit{RImp}(\mathit{Spec}) ) \wedge t$ satisfies causal delivery $\}$. This holds trivially when $t_1 \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec}) )$. 

For the case when $t_1 \in \mathit{trace}( \mathit{RImp}(\mathit{Spec}) )$. Since $t_1 \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$, there exists a number $u$, such that $\alpha_1 \cdot \ldots \cdot \alpha_u \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$ and $\alpha_1 \cdot \ldots \cdot \alpha_{u-1} \in \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$. Since $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$ is deterministic, it is easy to see that $\alpha_u$ is a $\mathit{addDel}$ transition and it violates the transition condition of $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$. Assume that $q_{\mathit{u-1}} = (O_{u-1},\mathit{ro}_{u-1},\mathit{del}_{u-1},\mathit{arb}_{u-1})$. Then, there must exists $o_3,o_4 \in O_{u-1}$, such that $(o_3,o_4) \in \mathit{hb}_{u-1}$, $o_3,o_4 \notin \mathit{visTo}(O_{u-1},r,\mathit{vis}_{u-1})$, and $\alpha_u = \mathit{addDel}(o_4,r)$. This violates causal delivery. $\qed$ 
\end {proof}













\section{Definitions and Proofs of Section \ref{sec:succinct reference implementations of collection data types}}
\label{sec:appendix definitions and proofs of section succinct reference implementations of collection data types} 

The following lemma states that, if $q'_1 = \mathit{frg}(q_1,S)$ and $q_1 {\xrightarrow{\alpha}}_r q_2$ in $\mathit{RImp}(\mathit{Spec})$, then $q'_1 {\xrightarrow{\alpha}}_s q'_2$ in in $\mathit{SRImp}(\mathit{Spec})$ and $q'_2 = \mathit{frg}(q_2,S)$, where $\alpha'$ is obtained from $\alpha$ by removing operation of $S$.  

\begin{lemma}
\label{lemma:RImpcdSpec contains all the sequences of RImpSpec that are causal delivery}
If $q'_1 = \mathit{frg}(q_1,S)$ and $q_1 {\xrightarrow{\alpha}}_r q_2$ in $\mathit{RImp}(\mathit{Spec})$, then $q'_1 {\xrightarrow{\alpha}}_s q'_2$ in in $\mathit{SRImp}(\mathit{Spec})$ and $q'_2 = \mathit{frg}(q_2,S)$. If $\alpha = \mathit{addDel}(o,r) \wedge o \in S$, then $\alpha' = \epsilon$; Else, $\mathit{arb}'$ is obtained from $\alpha$ by removing operation of $S$. 
\end{lemma}

\begin {proof} 

Let us consider all possible cases of transition: 

\[
\begin{array}{l c}
\bigfrac{ o \in O, (o,r)\notin visTo(O,r,\mathit{vis}) }
{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{addDel(o,r)}} (O,\mathit{ro},\mathit{del} \cup \{ (o,r) \},\mathit{arb}) } %{\mathit{Delivery}}
\end{array}
\]


\[
\begin{array}{l c}
\bigfrac{ m \in \mathbb{Q}, \ell = m(a) \Rightarrow b, o=(\ell,r,\_) \notin O, \exists x, x \in f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o) \wedge x \in Spec(\ell) }
{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{m(a,b,r,\mathit{arb})}} (O,\mathit{ro},\mathit{del},\mathit{arb}) } %{\mathit{Query}}
\end{array}
\]


\[
\begin{array}{l c}
\bigfrac{ m \in \mathbb{U}, \ell = m(a) \Rightarrow b, o = (\ell,r,\_) \notin O, \exists y=\mathit{rand}(\mathit{arb},o), \exists x = (O',\_,y \uparrow_{O'} ) \in f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o) \wedge x \in Spec(\ell) }
{ (O,\mathit{ro},\mathit{del},\mathit{arb}) {\xrightarrow{m(a,b,r,y)}} (O \cup \{ o \},\mathit{ro} \oplus o ,\mathit{del} \oplus o,y) } %{\mathit{Update}}
\end{array}
\]

This completes the proof of this lemma. $\qed$
\end {proof}






{\noindent \bf Theorem \ref{theorem:SRIMPSpec and RIMPSpec have same history}}: $\mathit{his}(\mathit{RImp}(\mathit{Spec})) = \mathit{his}(\mathit{SRImp}(\mathit{Spec}))$. 

\begin {proof} 

Let $\rightarrow_r$ and $\rightarrow_s$ be the transition relation of $\mathit{RImp}(\mathit{Spec})$ and $\mathit{SRImp}(\mathit{Spec})$, respectively. Let us use $\mathit{Prop}_1$ to refer to 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] For each annotated history $x = (O,\mathit{vis},\mathit{arb})$ and $S \subseteq O$, where $S$ can be forgotten from $O$: For each operation label $\ell$ and extension $x'$ of $x$, let $y'$ be the operation context of $x'$ and $o \in O$, and let $y''$ be the operation context of $frg(x',S)$ and $o$, then $y' \in Spec(\ell)$, if and only if $y'' \in Spec(\ell)$. 
\end{itemize}

Let us use $\mathit{Prop}_2$ to refer to 

\begin{itemize}
\setlength{\itemsep}{0.5pt} 
\item[-] If $\mathit{frg}(q,S) = q' \wedge \mathit{frg}(q',S') = q''$, then $\mathit{frg}(q,S \cup S') =q''$.
\end{itemize}




Let us prove the $\subseteq$ direction. Given a execution $q_0 {\xrightarrow{\alpha_1}}_r q_1 \ldots$ of $t$, 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $q_0 {\xrightarrow{\alpha_1}}_r q_1$: By definition of $\rightarrow_s$, we know that there exists $S_1$ and state $q'_1$, such that $q'_1 = \mathit{frg}(q_1,S)$ and $q_0 {\xrightarrow{\alpha_1}}_s q'_1$. 

\item[-] $q_1 {\xrightarrow{\alpha_2}}_r q_2$: Since $q'_1 = \mathit{frg}(q_1,S)$ and $\mathit{Prop}_1$, we can see that $q'_1 {\xrightarrow{\alpha'_2}}_r q'_2$, $q'_2 = \mathit{frg}(q_2,S_1)$, where $\alpha'_2$ is generated from $\alpha_2$ by removing operations of $S_1$ from the arbitration order.

By definition of $\rightarrow_s$, we know that there exists $S_1$ and state $q'_1$, such that $q'_1 = \mathit{frg}(q_1,S)$ and $q_0 {\xrightarrow{\alpha_1}}_s q'_1$.
\end{itemize}

This completes the proof of this lemma. 

$\qed$
\end {proof}






To obtain the annotated history of traces of $SRImp(Spec)$, let us define a relation $R_S$. Given two states $q=(O,\mathit{ro},\mathit{del},\mathit{vis}),q'$ of $RImp(Spec)$ and a set $S$ of operations, $(q,q') \in R_S$, if $P_f(O,\mathit{vis},S) \wedge q' = forg(q,S)$. With our definition of collections, we can see that $R_S$ satisfies the following properties:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $(q,q') \in R_{ S_1 } \wedge (q',q'') \in R_{ S_2 }$, then $(q,q'') \in R_{ ( S_1 \cup S_2 ) }$.

\item[-] If $(q_i,q'_i) \in R_{S} \wedge q'_i {\xrightarrow{\alpha'}} q'_{i+1}$, then $\exists \alpha$, such that $q_i {\xrightarrow{\alpha}} q_{i+1} \wedge (q_{i+1},q'_{i+1}) \in R_{S}$, where

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $\alpha' = addDel(o,r)$,then $\alpha = \alpha'$.

    \item[-] If $\alpha'=(m,a,b,r,\mathit{arb}')$, then $\exists \mathit{arb}$, such that $\alpha=(m,a,b,r,\mathit{arb}) \wedge \mathit{arb}' = \mathit{arb} - S$.
    \end{itemize}
\end{itemize}


Given an execution $t = \alpha_1 \cdot \ldots$ of $SRImp(Spec)$, its annotated history $anHis(t)$ is the annotated history of a trace $t' = \alpha'_1 \cdot \alpha''_2 \ldots$ of $RImp(Spec)$ generated as follows: Assume $q_0 {\xrightarrow{\alpha_1}}_s q_1 \ldots$ is an execution of $SRImp(Spec)$, and let $\rightarrow_r$ be the transition relation of $RImp(Spec)$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $q_0 {\xrightarrow{\alpha_1}}_s q_1$: By definition of $\rightarrow_s$, $\exists \alpha'_1, q'_1$, such that $q_0 {\xrightarrow{\alpha'_1}}_r q'_1 \wedge q_1 = suct(q'_1)$. Assume we obtain $q_1$ from $q'_1$ by forgetting $S_1$. It is obvious that $(q'_1,q_1) \in R_{S_1}$.

\item[-] $q_1 {\xrightarrow{\alpha_2}}_s q_2$: Similarly, $\exists \alpha'_2, q'_2, S_2$, such that $q_1 {\xrightarrow{\alpha'_2}}_r q'_2 \wedge q_2 = suct(q'_2) \wedge (q'_2,q_2) \in R_{S_2}$. Since we already know that $(q'_1,q_1) \in R_{S_1} \wedge q_1 {\xrightarrow{\alpha'_2}}_r q'_2$, we can see that $\exists \alpha''_2,q''_2$, such that $q'_1 {\xrightarrow{\alpha''_2}}_r q''_2 \wedge (q''_2,q'_2) \in R_{S_1}$. Therefore, $(q''_2,q_2) \in R_{( O_1 \cup O_2)}$.

%By definition of $\rightarrow_s$, $\exists \alpha'_2, q'_2$, such that $q_1 {\xrightarrow{\alpha'_2}}_r q'_2 \wedge q_2 = suct(q'_2)$. Assume we obtain $q_2$ from $q'_2$ by forgetting $S_2$. It is obvious that $(q'_2,q_2) \in R_{S_2}$.
\item[-] $q_k {\xrightarrow{\alpha_{\mathit{k+1}}}}_s q_{\mathit{k+1}}$ and $k \geq 2$: Similarly, $\exists \alpha'_{\mathit{k+1}}, q'_{\mathit{k+1}}, S_{\mathit{k+1}}$, such that $q_k {\xrightarrow{\alpha'_{\mathit{k+1}}}}_r q'_{\mathit{k+1}} \wedge q_{\mathit{k+1}} = suct(q'_{\mathit{k+1}}) \wedge (q'_{\mathit{k+1}},q_{\mathit{k+1}}) \in R_{S_{\mathit{k+1}}}$. Since we already know that $(q''_k,q_k) \in R_{( S_1 \cup \ldots \cup S_k )} \wedge q_k {\xrightarrow{\alpha'_\mathit{k+1}}}_r q'_{\mathit{k+1}}$, we can see that $\exists \alpha''_{\mathit{k+1}} ,q''_{\mathit{k+1}} $, such that $q'_k {\xrightarrow{\alpha''_{\mathit{k+1}} }}_r q''_{\mathit{k+1}}  \wedge (q''_{\mathit{k+1}} ,q'_{\mathit{k+1}} ) \in R_{( S_1 \cup \ldots \cup S_k )}$. Therefore, $(q''_{\mathit{k+1}} ,q_{\mathit{k+1}} ) \in R_{( S_1 \cup \ldots \cup S_{\mathit{k+1}}  )}$.
\end{itemize}


%\figurename~\ref{fig:the process of generate abstract trace for compacted reference implementation} shows the example when the trace of $CRImp(Spec)$ is $\alpha_1 \cdot \alpha_2 \cdot \alpha_3 \cdot \alpha_4$.

%\begin{figure}[t]
%  \centering
%  \includegraphics[width=0.4 \textwidth]{figures/PIC-Generate-AbstractTrace-Compact.pdf}
%\vspace{-10pt}
%  \caption{The process of generate abstract trace for compacted reference implementation}
%  \label{fig:the process of generate abstract trace for compacted reference implementation}
%\end{figure}



{\noindent \bf Lemma \ref{lemma:Minus for OR-set is correct}}: Our definition of $Minus$ for OR-set is correct.

\begin {proof}

Let $\rightarrow$ be the transition relation of $RImp(S_{\mathit{ORS}})$. Given $(q_k,q'_k) \in R_{S}$, let $f$ be short for $map_{(q_k,q'_k,S)}$, assume $q_k = (O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k)$ and $q'_k = (O'_k,\mathit{ro}'_k,\mathit{del}'_k,\mathit{arb}'_k)$. Let us prove the requirements of $Minus$ one by one:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q'_k {\xrightarrow{addDel(o',r)}} q'_{k+1}$: It is obvious that $f(o') \notin O$. Since the visibility relation over $O_k - S$ is the same as the visibility relation over $O'_k$, we have $q_k {\xrightarrow{addDel(f(o'),r)}} q_{k+1}$. Since the only change of visibility from $q_k$ to $q_{k+1}$ is $(f(o'),r)$, and the only change of visibility from $q'_k$ to $q'_{k+1}$ is $(o',r)$, we can see that $(q_{k+1},q'_{k+1}) \in R_{S}$.

\item[-] If $q'_k {\xrightarrow{(add,a,r,\emptyset)}} q'_{k+1}$: Assume $O'_{k+1} - O'_k = o'$. $q_k {\xrightarrow{(add,a,r,\emptyset)}} q_{k+1}$ always holds and assume $O_{k+1} - O_k = o$. Let $f' = f \cup \{ (o,o') \}$. With $f'$ it is easy to see that $(q_{k+1},q'_{k+1}) \in R_{S}$.

\item[-] If $q'_k {\xrightarrow{(rem,a,r,\emptyset)}} q'_{k+1}$: Assume that $O'_{k+1} - O'_k = o'$. It is obvious that $lab(o') = rem(a)$. Let $ctxt(q'_k,o') = (O'_{ck},<'_{ck},\emptyset)$. Then $\exists o'_a \in O'_{ck}$, such that $lab(o'_a) = add(a)$, and $o'_a$ is maximal w.r.t $<'_{ck}$ in $O'_{ck} \uparrow_{ (add(a),rem(a)) }$.

    Let $o_a = f(o'_a)$. Let $o=(add(a),r,\_) \notin O_k$. In $ctxt(q_k,o) = (O_{ck},<_{ck},\emptyset)$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $o_a$ is maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$: We have $(O_k,\mathit{ro}_k,\mathit{del}_k,\emptyset) {\xrightarrow{add(a,r,\emptyset)}} q_{k+1}$ where $q_{k+1} = (O_k \cup \{ o \},\mathit{ro}_k \oplus o , \mathit{del}_k \oplus o,\emptyset)$. Let $f' = f \cup \{ (o,o') \}$. With $f'$ it is easy to see that $(q_{k+1},q'_{k+1}) \in R_{S}$.

    \item[-] If $o_a$ is not maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$: Then,

        \begin{itemize}
        \setlength{\itemsep}{0.5pt}
        \item[-] Since $<_{ck}$ preservers pairs that are in $Minus$, for each operation $o_1 \in S \wedge lab(o_1) = add(a)$, $o_1$ could not be maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$.

        \item[-] If there exists $o_{nr}$, such that $o_{nr} \notin S$, $lab(o_{nr}) = rem(a)$, and $o_2$ is maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$: It is obvious that $f(o_{nr}) \in Q'_k$. Since (1) the visibility over $O_k - S$ in $q_k$ is the same as that over $Q'_k$ in $q'_k$, and (2) the definition of $<_{ck}$ and $<'_{ck}$, we can see that $f(o_{nr})$ is still maximal w.r.t $<'_{ck}$ in $O'_{ck} \uparrow_{ (add(a),rem(a)) }$.

        \item[-] Based on above item and the assumption that $o'_a$ is maximal w.r.t $<'_{ck}$ in $O'_{ck} \uparrow_{ (add(a),rem(a)) }$, we can see that there exists $o_r$, such that $o_r \in S$, $lab(o_r) = rem(a)$, $o_r$ is maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$, and $(o_a,o_r) \in <_{ck}$:

            Since $o_r \in S \wedge o_a \notin S$, we know that $o_r \notin Minus(q_k,o_a)$.

            From $(o_a,o_r) \in <_{ck}$, we know see that $(o_a,o_r) \in \mathit{vis}_k$. Let $(o_a,o_1),(o_1,o_2),\ldots,(o_{u-1},o_u),(o_u,o_r)$ be the largest number of pairs that are all in $\mathit{vis}_k$. Since $o_r \notin Minus(q_k,o_a)$, by the definition of $<_{ck}$ we know that $o_1,\ldots,o_u,o_a,o_r \in visTo(q_k,r,\mathit{vis}_k)$.

            By the definition of $Minus$, there exists index $v$, such that $(o_a,o_v),(o_v,o_r) \in \mathit{vis}_k$ and $o_v \in Minis(q_k,o_a)$. Then, in $q'_k$, we can see that $(o'_a,f(o_1)),(f(o_1),f(o_2)),\ldots,(f(o_{u-1}),f(o_u)) \in \mathit{vis}'_k$ and $o_a,f(o_1),\ldots,f(o_v) \in visTo(q'_k,r,\mathit{vis}'_k)$. This implies that $(o'_a,f(o_v)) \in <'_{ck}$, contradicts the assumption that $o'_a$ is maximal w.r.t $<'_{ck}$ in $O'_{ck} \uparrow_{ (add(a),rem(a)) }$. Therefore, such $o_r$ could not exist.
        \end{itemize}
    \end{itemize}

\item[-] If $q'_k {\xrightarrow{(contains,a,\mathit{true},r,\emptyset)}} q'_{k+1}$: Similarly as above case.

\item[-] If $q'_k {\xrightarrow{(contains,a,\mathit{false},r,\emptyset)}} q'_{k+1}$: Let $o' = (contain(a,\textit{false}),r,\_) \notin O'_k$ and $ctxt(q'_k,o') = (O'_{ck},<'_{ck},\emptyset)$. Then for each operation of $O'_{ck}$ with operation label $add(a)$, it is not maximal w.r.t $<'_{ck}$ in $O'_{ck} \uparrow_{ (add(a),rem(a)) }$.

    Let $o = (contain(a,\textit{false}),r,\_) \notin O_k$. In $ctxt(q_k,o) = (O_{ck},<_{ck},\emptyset)$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Since $<_{ck}$ preservers pairs that are in $Minus$, for each operation $o_1 \in S \wedge lab(o_1) = add(a)$, $o_1$ could not be maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$.

    \item[-] If there exists $o_a \notin S$, such that $lab(o_a) = add(a)$, and $o_a$ is maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$: We can see that, in $q'_k$, there exists $o'_{r1}$, such that $lab(o'_{r1}) = rem(a)$, and $(f(o_a),r'_{r1}) \in <'_{ck}$, and then $(f(o_a),o'_{r1}) \in \mathit{vis}'_k$. By the definition of $Minus$, there exists $o'_r$, such that $o'_r \in Minus(q'_k,f(o_a))$, and $(f(o_a),o'_r), (o'_r,o'_{r1}) \in \mathit{vis}'_k$.

        Then, we can see that $(o_a,f(o'_r)) \in \mathit{vis}_k$. It is easy to prove that $f(o'_r) \in Minus(q_k,o_a)$, and then we can see that $(o_a,f(o'_r)) \in <_{ck}$, contradicts the assumption that $o_a$ is maximal w.r.t $<_{ck}$ in $O_{ck} \uparrow_{ (add(a),rem(a)) }$. Therefore, such $o_a$ could not exist.
    \end{itemize}

\item[-] If $q'_k {\xrightarrow{(elements,S,r,\emptyset)}} q'_{k+1}$: This can be implied from the cases of $q'_k {\xrightarrow{(contains,a,\mathit{true},r,\emptyset)}} q'_{k+1}$ and $q'_k {\xrightarrow{(contains,a,\mathit{false},r,\emptyset)}} q'_{k+1}$.

\end{itemize}

Given $(q,q') \in R_{ S_1 }$ and $(q',q'') \in R_{ S_2 }$, we need to prove that $(q,q'') \in R_{ ( S_1 \cup S_2 ) }$.

Assume $q=(O,\mathit{ro},\mathit{del},\emptyset)$, $q'=(O',\mathit{ro}',\mathit{del}',\emptyset)$ and $q''=(O'',\mathit{ro}'',\mathit{del}'',\emptyset)$. We already know that, $q' = forg(q,S_1)$, $match(q,S_1)$, $q'' = forg(q',S_2)$ and $match(q',S_2)$. Let $f = map_{(q,q',S_1)}$ and $f' = map_{(q',q'',S_2)}$. Precisely, we need to prove that $(q,q'') \in R_{ ( S_1 \cup f(S_2) ) }$.

It is easy to see that $q'' = forg(q,S_1 \cup f(S_2))$. To prove $mathch(q,S_1 \cup f(S_2))$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] For each $add$ operation $o_a \in S_1 \cup f(S_2)$ and each replica identifier $r$, it is obvious that $o_a \in visTo(O,r,vis)$.

\item[-] For each $rem$ operation $o_r \in S_1 \cup f(S_2)$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $o_r \in S_1$, then it is obvious that $\{ o_2 \vert o_r \in Minus(o_2) \} \subseteq S_1$.

    \item[-] If $o_r \in f(S_2)$, then it is obvious that in $q'$, we have $\{ o_3 \vert f(o_r) \in Minus(o_3) \} \subseteq S_2$. Since the different between visibility relations of $q$ and $q'$ map only be that of $S_1$, we have that in $q$, $\{ o_4 \vert o_r \in Minus(o_4) \} \subseteq S_1 \cup f(S_2)$.
    \end{itemize}
\end{itemize}

Therefore, $mathch(q,S_1 \cup f(S_2))$ holds, and $(q,q'') \in R_{ ( S_1 \cup f(S_2) ) }$. This completes the proof of this lemma. $\qed$
\end {proof}




{\noindent \bf Lemma \ref{lemma:Minus for distributed list is correct}}: Our definition of $Minus$ for distributed list is correct.
\begin {proof}

Let $\rightarrow$ be the transition relation of $RImp(S_{\mathit{ORS}})$. Given $(q_k,q'_k) \in R_{S}$, let $f$ be short for $map_{(q_k,q'_k,S)}$, assume $q_k = (O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k)$ and $q'_k = (O'_k,\mathit{ro}'_k,\mathit{del}'_k,\mathit{arb}'_k)$. Let us prove the requirements of $Minus$ one by one:


We need to prove that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] given $(q_i,q'_i) \in R_{O}$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $q'_i {\xrightarrow{\alpha'}} q'_{i+1}$, then $q_i {\xrightarrow{\alpha}} q_{i+1} \wedge (q_{i+1},q'_{i+1}) \in R_{S}$, where

        \begin{itemize}
        \setlength{\itemsep}{0.5pt}
        \item[-] If $\alpha' = addDel(o',r)$,then $\alpha = addDel(o,r)$, where $map_{(q,q',S)}(o')=o$.

        \item[-] Else, if $\alpha'=(m,a,b,r,\mathit{arb}')$, then $\exists \mathit{arb}$, such that $\alpha=(m,a,b,r,\mathit{arb}) \wedge \mathit{arb}' = map_{(q,q',S)}(\mathit{arb} - S)$.
        \end{itemize}
    \end{itemize}

\item[-] Given $(q,q') \in R_{ S_1 }$ and $(q',q'') \in R_{ S_2 }$. Then, we require that $(q,q'') \in R_{ ( S_1 \cup map_{(q,q',S_1)}(S_2) ) }$. For simplicity, we write $(q,q'') \in R_{ ( S_1 \cup S_2 ) }$ instead.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}















\section{Definitions and Proofs of Section \ref{sec:simulation relation for CRDT implementations}}
\label{sec:appendix definitions and proofs of section simulation relation for CRDT implementations}


Given a trace $t = \alpha_1 \cdot \ldots \cdot \alpha_k$ of $Sem(imp)$, $f_t(t)$ works as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] We have a state $q_s$ and a map $\mathit{map}$. Their initial value is the initial state of $SRImp(Spec)$ and $\emptyset$, respectively.

\item[-] Assume we have already dealt with $\alpha_1 \cdot \ldots \cdot \alpha_{u-1}$.

\item[-] If $\alpha_u = apply(m)$, where $m$ is of element $x$ and its destination replica is $r$: $\beta_u = addDel(map(x),r)$, and update $q_s$ with $\beta_u$.

\item[-] If $\alpha_u = (m,a,b,r,\mathit{arb}_{\mathit{imp}})$: Let $\mathit{arb}_{u-1}^s$ is the arbitration of $q_s$. If $m$ is a query or $\mathit{rem}$ operation, then $\beta_u = (m,a,b,r,\mathit{arb}_{u-1}^s)$; Else, $\beta_u = (m,a,b,r,\mathit{arb}_{u-1}^{'s})$, where $\mathit{arb}_{u-1}^{'s}$ is obtained from $\mathit{arb}_{u-1}^s$ by inserting the $add$ operation at some place, while consistent with $\mathit{arb}_{\mathit{imp}}$. After we obtain $\beta_u$, we update $q_s$ with $\beta_u$.

\item[-] $f_t(t) = \beta_k$.
\end{itemize}
























\section{Definitions and Proofs of Section \ref{sec:implementation}}
\label{sec:appendix definitions and proofs of section implementation}


An trace of implementation satisfies causal-delivery, if given $o_1 <_{\mathit{hb}} o_2$, then we can apply message generated by $o_2$ on a replica, if the message generated by $o_1$ has already been applied on this replica. The semantics of $imp$ with causal delivery is given as an LTS $OS(imp)_{\mathit{cd}} = (Q_{\mathit{cd}},\Sigma,\rightarrow_{\mathit{cd}},q_0)$, where

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $Q_{\mathit{cd}}$ is for the from $(data,msgs,\mathit{hb})$, where $data$ and $msgs$ is the same as that in $OS(imp)$, and $\mathit{hb} \subseteq (msgs \times msgs) \cup (msgs \times \mathbb{R})$ is a transitive, acyclic and irreflexive relation. $\mathit{hb}$ is used to record the happen-before relation between ``operations'' of messages. %$(m_1,m_2) \in <$ represents that the $op(m_1)$ happen before $op(m_2)$, while $(m,r) \in <$ represents that $op(m)$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.
    $(m_1,m_2) \in \mathit{hb}$, if the operation generating $m_1$ happens before the operation generating $m_2$, and $m_1$ and $m_2$ have same destination replica. $(m,r) \in \mathit{hb}$ represents that the operation generating $m$ is visible to replica $r$ and does not happen before any operation of replica $r$ currently.

\item[-] $\rightarrow_{\mathit{cd}}$ is the transition relation:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] When $m$ is a query method:

    $\begin{array}{l c} \bigfrac{ f_M(data[r],m,a,r) = (d,b,\emptyset),f_{arb}(data[r:d],msgs) = \mathit{arb}} {(data,msgs,\mathit{hb}) {\xrightarrow{(m,a,b,r,\mathit{arb})}} (data[r:d],msgs,\mathit{hb})} \end{array}$

    \item[-] When $m$ is a update method:

    $\begin{array}{l c} \bigfrac{ f_M(data[r],m,a,r)= (b,d,msgs'), f_{arb}(data[r:d],msgs \cup msgs') = \mathit{arb} } {(data,msgs,\mathit{hb}) {\xrightarrow{(m,a,b,r,\mathit{arb})}} (data[r:d],msgs \cup msgs',\mathit{hb} \otimes msgs')} \end{array}$

    Assume message of $msgs'$ is in the form $(da,\_,\_)$. Let $msgs(r)$ be the set of messages of $msgs$ with destination replica identifier $r$. $\mathit{hb} \otimes msgs'$ returns a new happen-before relation as follows:

        \begin{itemize}
        \setlength{\itemsep}{0.5pt}
        \item[-] For each replica $r' \in \mathbb{R}$, in $msgs(r')$, if $(m_1,r) \in \mathit{hb}$, then remove $(m_1,r)$ from $\mathit{hb}$ and add $(m_1,(da,r,r'))$ into $\mathit{hb}$,

        \item[-] For each replica $r' \in \mathbb{R}$, if $m_1$ is maximal among $\{ (\_,r,r') \}$ w.r.t $\mathit{hb}$, then add $(m_1,(da,r,r'))$ into $\mathit{hb}$.

        \item[-] Make $\mathit{hb}$ a transitive closure.
        \end{itemize}

    \item[-]

        $\begin{array}{l c} \bigfrac{ f_{apl}(data[r],r,m) = d, m \ is \ minimal \ w.r.t \ \mathit{hb} \ among \ msgs(r) } {(data,msgs,\mathit{hb}) {\xrightarrow{apply(m)}} (data[r:d],msgs - \{ m \}, \mathit{hb} \otimes m )} \end{array}$

         Assume $m = (da,r_m,r)$. $\mathit{hb} \otimes m$ returns a new happen-before relation as follows:

        \begin{itemize}
        \setlength{\itemsep}{0.5pt}
        \item[-] Remove $m$ from $\mathit{hb}$ while keeps the relation for other elements unchanged.

        \item[-] Then, for each $r' \neq r$, if $(da,r_1,r') \in msgs(r')$, then add $((da,r_m,r'),r)$ into $\mathit{hb}$.

        \item[-] Make $\mathit{hb}$ a transitive closure.
        \end{itemize}
    \end{itemize}
%\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset,\emptyset)$.
\end{itemize}

The following lemma states that, $\llbracket imp \rrbracket_{cd}$ contains the set of causal delivery executions of $\llbracket imp \rrbracket$. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section implementation}.

\begin{lemma}
\label{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}

$\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.
\end{lemma}


{\noindent \bf Lemma \ref{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}}: $\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.

\begin {proof}

Given $t = \alpha_1 \cdot \ldots \in \llbracket imp \rrbracket_{cd}$, if there exists $q_1,\ldots \in Q$, such that $q_0 {\xrightarrow{\alpha_1}} q_1 {\xrightarrow{\alpha_2}} \ldots$. We need to prove the following property: On each state $q_i=(repD_i,msgs_i,<_i)$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $P_1$: $msgs_i = \{ (dat,r,r') \vert$ the operation generating this message is launched by replica $r$ and its message has not been applied to replica $r'$ in $t[1,i]\}$.

\item[-] $P_2$: $m_1 <_i m_2$, iff $m_1$ and $m_2$ have same destination replica, and the operation generating $m_1$ happens before the operation generating $m_2$ in $t[1,i]$.

\item[-] $P_3$: $m <_i r$, iff the destination replica of $m$ is not $r$, and the operation generating $m$ is visible to replica $r$ in $t[1,i]$, and does not happen before ``any operation that launched by replica $r$'' in $t[1,i]$.
\end{itemize}

Once we prove that $P_1$, $P_2$ and $P_3$ holds for each $q_i$, let us prove this lemma by contradiction: Assume that update operations $o_1 <_{hb} o_2$, messages of $o_1$ are $\{ (d_1,r_1,\_) \}$, messages of $o_2$ are \{ $(d_2,r_2,\_) \}$, $\alpha_i = apply((d_2,r_2,r'),r')$, $\alpha_j = apply((d_1,r_1,r'),r')$, and $i<j$. Then in $q_i=(repD_i,msgs_i,<_i)$, since $o_1 <_{hb} o_2$ and transition rules of $\llbracket imp \rrbracket_{cd}$, we could not launch $apply((d_2,r_2,r'),r')$ transition, which is the contradiction.



Let us begin to prove that each state $q_i=(repD_i,msgs_i,<_i)$ satisfies properties $P_1$, $P_2$ and $P_3$. We prove this by induction on $t$.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] It is obvious that $q_0$ satisfies properties $P_1$, $P_2$ and $P_3$.

\item[-] Since $\alpha_1$ must be either a query transition or an update transition, it is easy to see that $<_1 = \emptyset$ and $q_1$ satisfies properties $P_1$, $P_2$ and $P_3$.

\item[-] Assume that $q_i=(repD_i,msgs_i,<_i)$ satisfies properties $P_1$, $P_2$ and $P_3$. let us consider $q_{i+1}= (repD_{i+1},msgs_{i+1},<_{i+1})$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $q_{i+1}$ is obtained from $q_i$ by a query transition, then this holds obviously.

    \item[-] Else, if $q_{i+1}$ is obtained from $q_i$ by a update transition. Then we can see that $(repD_i,msgs_i,<_i) {\xrightarrow{m(a,b,r)}} (repD_{i+1},msgs_{i+1}=msgs \cup \{ (dat,r,r') \vert  r' \in RId \wedge r \neq r' \},<_{i+1} = <_i \otimes dat)$.

        Since we add messages $\{ (dat,r,r') \vert  r' \in RId \wedge r \neq r' \}$ into $msgs_i$, we can see that $P_1$ holds.

        To satisfy $P_2$ and $P_3$, we need to make newly add messages maximal w.r.t $<$ and still keep transitivity, which is done by $<_i \otimes dat$.

    \item[-] Else, $q_{i+1}$ is obtained from $q_i$ by a applying transition. Then we can see that $(repD_i,msgs_i,<_i) {\xrightarrow{apply(m=(dat,r_1,r))}} (repD_{i+1},msgs_{i+1} = msgs_i - \{ m \}, <_{i+1} = <_i \otimes m )$, where $m$ is minimal w.r.t $<_i$ among messages in $msgs_i(r)$.

        Since we use one message $m$ in this process and remove it from $msgs_i$, we can see that $P_1$ holds.

        Applying message will introduce new visibility relation. To satisfy $P_2$ and $P_3$, we need to first forget $m$, record the newly introduced visibility relation, and still keep transitivity. This is done by $<_i \otimes m$.
    \end{itemize}
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}


















\section{Definitions and Proofs of Section \ref{sec:simulation and refinement}}
\label{sec:appendix definitions and proofs of section simulation and refinement}


{\noindent \bf Theorem \ref{theorem:equivalence of our simulation and refinement}}: Given LTS $A$ and deterministic $B$, and functions $f_s,f_t$, such that $P_{(f_s,f_t)}$ holds. Then, B $f_t$-refines $A$, if and only if there exists a $f_s$-simulation relation between $A$ and $B$.

\begin {proof}
Assume $A = (Q_A,\Sigma_A,\rightarrow_a,q_{0A})$ and $B = (Q_B,\Sigma_B,\rightarrow_b,q_{0B})$.

For the $\mathit{if}$ direction. Assume $R$ is a $f_s$-simulation relation between $A$ and $B$. Given $q_{1A},\ldots,q_{kA} \in Q_A$, $q_{1B},\ldots,q_{kB}$, $\alpha_1,\ldots,\alpha_k$, such that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\forall 0 \leq i < k$, $q_{iA} {\xrightarrow{\alpha_{i+1}}}_a q_{i+1A}$,

\item[-] $\forall 0 \leq i \leq k$, $(q_{iA},q_{iB}) \in R$, and

\item[-] $\forall 0 \leq i < k$, $q_{iB} {\xrightarrow{f_s(q_{iA},q_{iB},\alpha_{i+1})}}_b q_{i+1B}$.
\end{itemize}

We can see that, given execution $t_A = \alpha_1 \cdot \ldots \cdot \alpha_k$ of $A$, by $f_s$-simulation, we have execution $t_b = f_s(q_{0A},q_{0B},\alpha_1) \cdot \ldots \cdot f_s(q_{k-1A},q_{k-1B},\alpha_k)$ of $B$.

Since $P_{(f_s,f_t)}$ holds, we can see that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $f_t(\alpha_1) = f_s(q_{0A},q_{0B},\alpha_1)$.

\item[-] $f_t(\alpha_1 \cdot \alpha_2) = f_s(q_{1A},q'_{1B},\alpha_2)$. Here $q'_{1B}$ is obtained from $q_{B0}$ by doing $\alpha_1$ transitions. Since $B$ is deterministic, it is easy to see that $q'_{1B} = q_{1B}$, and $f_t(\alpha_1 \cdot \alpha_2) = f_s(q_{1A},q_{1B},\alpha_2)$.

$\ldots$

\item[-] $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k) = f_s(q_{k-1A},q'_{k-1B},\alpha_k)$. Here $q'_{k-1B}$ is obtained from $q_{B0}$ by doing $\alpha_1 \cdot \ldots \cdot \alpha_{k-1}$ transitions. Since $B$ is deterministic, it is easy to see that $q'_{k-1B} = q_{k-1B}$, and $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k) = f_s(q_{k-1A},q_{k-1B},\alpha_k)$.
\end{itemize}

We can see that $t_B = f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)$. Therefore, by definition of $f_t$-refinement, we can see that B $f_t$-refines $A$.


For the $\mathit{only if}$ direction. Assume $B$ $f_t$-refines $A$. Let a relation $R_t$ be defined as follows: Given $q_A \in Q_A$ and $q_B \in Q_B$, $(q_A,q_B) \in R_t$, if $\exists \alpha_1, \ldots, \alpha_k \in \Sigma_A$, $\exists q_{1A},\ldots,q_{k-1A} \in Q_A$, and $\exists q_{1B},\ldots,q_{k-1B} \in Q_B$, such that $q_{0A} {\xrightarrow{\alpha_1}}_a q_{1A} \ldots {\xrightarrow{\alpha_{k-1}}}_a q_{k-1A} {\xrightarrow{\alpha_k}}_a q_A$, and $q_{0B} {\xrightarrow{f_t(\alpha_1)}}_b q_{1B} \ldots$ ${\xrightarrow{f_t(\alpha_1 \cdot \cdot \ldots \cdot \alpha_{k-1})}}_b q_{k-1B} {\xrightarrow{f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)}}_b q_B$.

Let us now prove that $R_t$ is a $f_s$-simulation relation. Assume that $q_A {\xrightarrow{\alpha}}_a q'_A$. Then we can see that $q_{0A} {\xrightarrow{\alpha_1}}_a q_{1A} \ldots {\xrightarrow{\alpha_{k-1}}}_a q_{k-1A} {\xrightarrow{\alpha_k}}_a q_A {\xrightarrow{\alpha}}_A q'_A$ and $\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha$ is an execution of $A$.

By assumption, $B$ $f_t$-refines $A$. Therefore, $f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k) \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha)$ is an execution of $B$. Since $B$ is deterministic, we can see that $\exists q'_B$, such that $q_{0B} {\xrightarrow{f_t(\alpha_1)}}_b q_{1B} \ldots$ ${\xrightarrow{f_t(\alpha_1 \cdot \cdot \ldots \cdot \alpha_{k-1})}}_b q_{k-1B} {\xrightarrow{f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)}}_b q_B {\xrightarrow{f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha)}}_b q'_B$. By definition, we can see that $(q'_A,q'_B) \in R_t$.

Since $P_{(f_s,f_t)}$ holds, we have that $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha) = f_s(q_A,q''_B,\alpha)$, where $q''_B$ is obtained from $q_{0B}$ by doing $f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)$ transitions. Since $B$ is deterministic, we can see that $q''_B = q_B$ and $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha) = f_s(q_A,q_B,\alpha)$. We can see that $q_B {\xrightarrow{f_s(q_A,q_B,\alpha)}}_b q'_B$. Therefore, $R_t$ is a $f_s$-simulation relation. \qed
\end {proof}

\forget
{
The $\mathit{only if}$ direction is obvious.

Let us prove the $\mathit{if}$ direction. By assumption we already have that $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$. Assume $\llbracket imp \rrbracket = (Q_{imp},\Sigma_{imp},\rightarrow_{imp},q_{0imp})$ and $RImp(Spec) = (Q_s,\Sigma_s,vis,q_{0s},li,\rightarrow_s,livReq)$. A relation $R \subseteq Q_{imp} \times Q_s$ is defined as follows: $(q_i,q_s) \in R$, if $\exists t_{imp} = \alpha_1 \cdot \ldots \cdot \alpha_k,t_s = \beta_1 \cdot \ldots \cdot \beta_k, q_{1imp}, \ldots, q_{kimp}, q_{1s}, \ldots, q_{ks}$, such that $q_{0imp} {\xrightarrow{\alpha_1}}_{imp} q_{1imp} \ldots {\xrightarrow{\alpha_k}}_{imp} q_{kimp}$ is an execution of $\llbracket imp \rrbracket$, $q_{kimp}=q_i$, $q_{0s} {\xrightarrow{\beta_1}}_s q_{1s} \ldots {\xrightarrow{\beta_k}}_s q_{ks}$ is an execution of $RImp(Spec)$, $q_{ks}=q_s$, and $t_{imp}$ and $t_s$ correspond. Let us prove that $R$ is a simulation relation. Note that, given $t_{imp}$, there exists at most one $t_s$, such that $t_{imp}$ and $t_s$ correspond.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_{imp} {\xrightarrow{m(a,b,r)}}_{imp} q'_{imp}$: It is easy to see that $t'_{imp} = t_{imp} \cdot m(a,b,r) \in \llbracket imp \rrbracket$.

Since $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$, there exists $t'_s$ of $RImp(Spec)$, such that $t'_{imp}$ and $t'_s$ correspond.

Since given a trace $t$ of $\llbracket imp \rrbracket$, there exists at most one trace $t'$ of $RImp(Spec)$, such that $t$ and $t'$ correspond. It is easy to see that such $t'_s$ is unique.

Since $t_{imp}$ and $t_s$ correspond and $RImp(Spec)$ is deterministic, we can see that $t'_s = t' \cdot m(a,b,r)$ is an execution of $RImp(Spec)$. Let $q_{ks} {\xrightarrow{m(a,b,r)}}_s q'_s$ It is easy to see that $t'_{imp}$ and $t'_s$ correspond. Therefore, $(q'_{imp},q'_s) \in R$.

\item[-] If $q_{imp} {\xrightarrow{apply(m)}}_{imp} q'_{imp}$: It is easy to see that $t'_{imp} = t_{imp} \cdot apply(m) \in \llbracket imp \rrbracket$.

Since $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$, there exists $t'_s$ of $RImp(Spec)$, such that $t'_{imp}$ and $t'_s$ correspond.

Since given a trace $t$ of $\llbracket imp \rrbracket$, there exists at most one trace $t'$ of $RImp(Spec)$, such that $t$ and $t'$ correspond. It is easy to see that such $t'_s$ is unique.

We already know that $t_{imp}$ and $t_s$ correspond and $RImp(Spec)$ is deterministic. It is not hard to prove that, in $q_{kimp}$ and $q_{ks}$, $\forall r_1,r_2 \in RId$, the number of messages of $q_{kimp}$ which ``use source replica $r_1$ and destination replica $r_2$ and are still not applied'' is same as the number of operation of $q_{ks}$ which ``happens on replica $r_1$ and not visible to replica $r_2$''. Therefore, there exists transition $q_{ks} {\xrightarrow{addDel(o,r)}}_s q'_s$. Here $o$ and $r$ are obtained as follows: Assume after doing $t_{imp}$, $m=(\_,r',r)$ is the $i-th$ among ``messages with source replica $r'$, destination replica $r$ and still not applied'' w.r.t the occurring order of $t_{imp}$. Then, after doing $t_s$, $o$ is the $i-th$ among ``operations which happens on replica $r'$ and not visible to replica $r$'' w.r.t the occurring order of $t_s$. Let $t'_s = t' \cdot addDel(o,r)$.

Let us prove that such $m$, $o$ and $r$ satisfies the requirements in definition of simulation relation. Since we already know that $q_{0imp} {\xrightarrow{t_{imp}}}_{imp}^* q_{kimp}$ and $q_{0s} {\xrightarrow{t_s}}_s^* q_{ks}$, it is not hard to prove that, the $i-th$ message among ``messages with source replica $r'$, destination replica $r$ and still not applied'' w.r.t the occurring order of $t_{imp}$ is the same as the $i-th$ among messages of $q_{kimp}$ with source replica $r'$ and destination replica $r$ w.r.t $<_{sd}$. Similarly, we can prove that, the $i-th$ operations among ``operations which happens on replica $r'$ and not visible to replica $r$'' w.r.t the occurring order of $t_s$ is the same as the $i-th$ among operations of $q_{ks}$ which happens on replica $r'$ and not visible to replica $r$ w.r.t $ro$. Therefore, $o$ and $r$ satisfies the requirements in definition of simulation relation.

Let us prove that $(q'_{imp},q'_s) \in R$. From above discussion, it is not hard to see that $t'_{imp}$ and $t'_s$ correspond. Therefore, $(q'_{imp},q'_s) \in R$.
\end{itemize}
}






















































\forget
{

\section{Definitions of Section \ref{sec:specifications and consistencies}}
\label{sec:appendix definitions of section specifications and consistencies}

Let us give the definition of specification $S_{\mathit{list}}$ of distributed list specification. $(O,<,<_{\mathit{arb}}) \in S_{\mathit{list}}(x)$, if

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $<^{-1}$ contains finite elements, $<$ is acyclic and $<_{\mathit{arb}}$ is a total order of $add$ operations in $O \cup \{ o \}$, where $o \notin O$ and $o$ is in domain of $<_{\mathit{arb}}$. By definition of poset we can see that $cont(o)=x$. Let $KnownRemoved=\emptyset$.

\item[-] Step $1$: For each minimal operation $o_1$ w.r.t $<$, let $Op(o_1)=\{ o_1 \}$, $seq(o_1)$ be obtained by ordering elements of $Op(o_1)$ with $<_{\mathit{arb}}$ order. We require $cont(o_1)=add(\_,1)$.

\item[-] Step $i+1$: For each $o_2$, which are immediate successor of some $o_1$ of step $i$.

    If $<^{-1}(o_2)$ does not contain $rem$ operations:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Let $Op(o_2)$ be the set of $add$ operations in $<^{-1}(o_2) \cup \{ o_2 \}$, and let $seq(o_2)$ be obtained by ordering elements of $Op(o_2)$ with $<_{\mathit{arb}}$ order.

    \item[-] If $cont(o_2) = add(a,pos)$, then $seq(o_2)[pos] = o_2$.

    \item[-] Else, if $cont(o_2) = rem(pos,a)$, then $cont(seq(o_2)[pos])=add(a,\_)$. Let $o_a=seq(o_2)[pos]$. Let $KnownRemoved = KnownRemoved \cup \{ (o_a,o_2) \}$.
    \end{itemize}

    If $<^{-1}(o_2)$ contains $rem$ operations:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Let $O_r$ be the set of $rem$ operations in $<^{-1}(o_2)$. According to our construction, $\forall o_r \in O_r$, $\exists o_p$, such that $(o_p,o_r) \in KnownRemoved$.

    \item[-] Let $Op(o_2) = \{ o' \vert o'$ is a $add$ operation in $<^{-1}(o_2) \cup \{ o_2 \} \} - \{ o'_p \vert \exists o', (o'_p,o') \in KnownRemoved \}$. Let $seq(o_2)$ be obtained by ordering elements of $Op(o_2)$ with $<_{\mathit{arb}}$ order.

    \item[-] If $cont(o_2) = add(a,pos)$, then $seq(o_2)[pos] = o_2$.

    \item[-] Else, if $cont(o_2) = rem(pos,a)$, then $cont(seq(o_2)[pos])=add(a,\_)$. Let $o_a=seq(o_2)[pos]$. Let $KnownRemoved = KnownRemoved \cup \{ (o_a,o_2) \}$.
    \end{itemize}

\item[-] Assume we have investigated all operations in $O$.

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Let $O_r$ be the set of $rem$ operations in $O$. According to our construction, $\forall o_r \in O_r$, $\exists o_p$, such that $(o_p,o_r) \in KnownRemoved$.

    \item[-] Let $Op(o) = \{ o' \vert o'$ is a $add$ operation in $O \cup \{ o \} \} - \{ o'_p \vert \exists o', (o'_p,o') \in KnownRemoved \}$. Let $seq(o)$ be obtained by ordering elements of $Op(o)$ with $<_{\mathit{arb}}$ order.

    \item[-] If $cont(o) = add(a,pos)$, then $seq(o)[pos] = o$.

    \item[-] Else, if $cont(o) = rem(pos,a)$, then $cont(seq(o_2)[pos])=add(a,\_)$.

    \item[-] Else, if $cont(o)=read(\top,l)$, then is the sequence of operation contents of $seq(o)$.
    \end{itemize}
\end{itemize}


\begin{itemize}
\item[-] We check correctness of operations of $O$ with a procedure: Let $O_k$ be the operations we have already checked, and $KR$ record pairs $(o_1,o_2)$ such that the item added by $o_1$ have been removed by $o_2$. At the beginning, $O_k = \emptyset$ and $KR = \emptyset$. Then in each loop,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] Let $O_k = O_k \cup \{ o_1 \}$, where $<^{-1}(o_1) \subseteq O_k$.

    \item[-] Let $O_r$ be the set of $rem$ operations in $<^{-1}(o_1)$. %According to our construction, $\forall o_r \in O_r$, $\exists o_p$, such that $(o_p,o_r) \in KnownRemoved$.

    \item[-] Let $Op(o_1) = \{ o_2 \vert lab(o_2)=add(\_,\_) \in <^{-1}(o_1) \cup \{ o_1 \} \} - \{ o_3 \vert \exists o_4, (o_3,o_4) \in KR \}$. Let $seq(o_1)$ be obtained by ordering elements of $Op(o_1)$ with $arb$ order.

    \item[-] If $lab(o_1) = rem(pos,a)$, then we require that $lab(seq(o_1)[pos])=add(a,\_)$, and change $KR$ into $KR \cup \{ (seq(o_1)[pos],o_1) \}$.

    \item[-] Else, if $lab(o_1) = add(a,pos)$, then we require that $seq(o_1)[pos] = o_1$.
    \end{itemize}

    We require that this procedure be terminated with $O_k = O$.

\item[-] {\color {red}Let $Op(o) = \{ o_1 \vert lab(o_1)=add(\_,\_) \in <^{-1}(o) \cup \{ o \} \} - \{ o_2 \vert \exists o_3, (o_2,o_3) \in KR \}$, and let $seq(o)$ be obtained by ordering elements of $Op(o)$ with $arb$ order.}

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $lab(o)=add(a,pos)$, then we require that $seq(o)[pos]=o$.

    \item[-] Else, if $lab(o)=rem(pos,a)$, then we require that $lab(seq(o)[pos]) = add(a,\_)$.

    \item[-] Else, if $lab(o)=read(\top,list)$, then $list$ is the sequence of operation labels of seq(o).
    \end{itemize}
\end{itemize}


\section{Definitions and Proofs of Section \ref{sec:reference implementation}}
\label{sec:appendix definitions and proofs of section reference implementation}




We further require that when a new operation is generated, its candidate operation identifier is unique. Therefore, it is obvious that $RImp(Spec)$ is deterministic. Let $\llbracket RImp(Spec) \rrbracket$ be the set of traces of $RImp(Spec)$. Given an trace $ t= \alpha_1 \cdots$, the annotated history  $anHis(t) = (O,\mathit{vis},\mathit{arb})$ it admits is generated as follows: Let $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots$ be the execution of $t$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $O$ is the operations generated by transition rules during $t$.

\item[-] $(o_1,o_2) \in \mathit{vis}$, if one of the following cases holds: (1) $o_1$ is delivered into replica of $o_2$ before $o_2$ happens, (2) $o_1$ and $o_2$ are of same replica and $o_1$ happens earlier than $o_2$.

\item[-] $\mathit{arb}$ is the union of arbitration order of each $q_i$.
\end{itemize}



\subsection{Proof of Lemma \ref{lemma:executions of reference implementation are eventual consistent}}
\label{subsec:appendix proof of lemma executions of reference implementation are eventual consistent}

{\noindent \bf Lemma \ref{lemma:executions of reference implementation are eventual consistent}}: $\forall t \in \llbracket RImp(Spec) \rrbracket$, $poSet(t)$ is eventual consistent w.r.t $Spec$.

\begin {proof}

Assume $RImp(Spec) = (Q,\Sigma,vis,,q_0,li,\rightarrow,livReq)$, let $t = \alpha_1, \ldots, $ and $\exists q_1,\ldots$, such that $q_0 {\xrightarrow{\alpha_1}} q_1 {\xrightarrow{\alpha_2}} \ldots$, and $livReq(t) = \mathit{true}$. Let $poSet(t)=(O_t,<_t)$. Let $gi = (O_t,<_{gi})$ be the global interpretation of $t$.

For each operation $o$, assume $o$ is first introduced by a transition from $q_i$ to $q_{i+1}$, then, the local interpretation of $o$ is $li(q_i,r)$, where $r$ is the replica of $o$.

We prove this lemma by consider the four requirements individually:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{GIpf}$: Let us consider two kinds of operations $o$.

If $\exists o'$, such that $o' <_{gi} o$, then $\exists i < j$, such that $o'$ and $o$ are the operations of $\alpha_i$ and $\alpha_j$, respectively, and one of the following cases holds: (1) $o'$ and $o$ are of same replica, or (2) $\exists i', i < i' < j$, $\alpha_{i'}=addDel(o',r')$ and $r'$ is the replica of $o$. In each case, it is easy to see that $<^{-1}_{gi}(o)$ contains lee or equal operations than the set of operations in $t[1,j]$ and its number is obviously finite.

    If $\neg \exists o'$, such that $o' <_{gi} o$, then it is easy to see that $o$ is the first operation of its replica and no operation is delivered to that replica before $o$. In this case, it is obvious that $<^{-1}_{gi}(o)$ is finite.

\item[-] $\mathit{THINAIR}$: According to the definition, we could see that on each state $q_i$, local interpretation is a subset of visibility relation, and $ro$ is also a subset of visibility relation. It is easy to prove that on each state, $vis$ is acyclic.

\item[-] $\mathit{RVAL}$: We only need to consider query operations for $\mathit{RVAL}$ property, since only query operations have return values. According to construction of $\llbracket RImp(Spec) \rrbracket$, to launch a query operation $(m,a,b,rid,oid)$ transition of replica $r$ from state $q_i$, we already check whether $li(q_i,r)$, the local interpretation w.r.t $q_i$ and $r$, is in $Spec(m,a,b)$.

\item[-] $\mathit{EVENTUAL}$: Let $P=(O_P,<_P)$ be a finite prefix of $gi$.

We can see that $<_P$ is the visibility relation of operations in $O_P$. Let $O'_P = \{ o \vert \exists o_1,o_2 \in O_P,$ $o_1$ is visible to $o_2$ via $o'_1,\ldots,o'_m$, and $o \in \{ o'_1,\ldots,o'_n \} \}$. It is easy to see that $O'_P$ is finite, and assume that operations of $O_P \cup O'_P$ are chosen before $\alpha_{idx}$

Since $livReq(t)=true$, $\exists idx1$, such that in $t[1,idx1]$, all operations in $t[1,idx]$ has been delivered to every replica. According to our construction of $li$, this implies that for each state after $\alpha_{idx1}$ and each replica (1) its local interpretation contains $O_P$ and $O'_P$, and (2) the relation of local interpretation then contains the visibility relation between operations in $O_P$.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}








\section{Definitions and Proofs of Section \ref{sec:implementation}}
\label{sec:appendix definitions and proofs of section implementation}



{\noindent \bf Lemma \ref{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}}: $\llbracket imp \rrbracket_{cd} = \{ t \vert t \in \llbracket imp \rrbracket \wedge t$ satisfies causal delivery $\}$.

\begin {proof}

Given $t = \alpha_1 \cdot \ldots \in \llbracket imp \rrbracket_{cd}$, if there exists $q_1,\ldots \in Q$, such that $q_0 {\xrightarrow{\alpha_1}} q_1 {\xrightarrow{\alpha_2}} \ldots$. We need to prove the following property: On each state $q_i=(repD_i,msgs_i,<_i)$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $P_1$: $msgs_i = \{ (dat,r,r') \vert$ the operation generating this message is launched by replica $r$ and its message has not been applied to replica $r'$ in $t[1,i]\}$.

\item[-] $P_2$: $m_1 <_i m_2$, iff $m_1$ and $m_2$ have same destination replica, and the operation generating $m_1$ happens before the operation generating $m_2$ in $t[1,i]$.

\item[-] $P_3$: $m <_i r$, iff the destination replica of $m$ is not $r$, and the operation generating $m$ is visible to replica $r$ in $t[1,i]$, and does not happen before ``any operation that launched by replica $r$'' in $t[1,i]$.
\end{itemize}

Once we prove that $P_1$, $P_2$ and $P_3$ holds for each $q_i$, let us prove this lemma by contradiction: Assume that update operations $o_1 <_{hb} o_2$, messages of $o_1$ are $\{ (d_1,r_1,\_) \}$, messages of $o_2$ are \{ $(d_2,r_2,\_) \}$, $\alpha_i = apply((d_2,r_2,r'),r')$, $\alpha_j = apply((d_1,r_1,r'),r')$, and $i<j$. Then in $q_i=(repD_i,msgs_i,<_i)$, since $o_1 <_{hb} o_2$ and transition rules of $\llbracket imp \rrbracket_{cd}$, we could not launch $apply((d_2,r_2,r'),r')$ transition, which is the contradiction.



Let us begin to prove that each state $q_i=(repD_i,msgs_i,<_i)$ satisfies properties $P_1$, $P_2$ and $P_3$. We prove this by induction on $t$.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] It is obvious that $q_0$ satisfies properties $P_1$, $P_2$ and $P_3$.

\item[-] Since $\alpha_1$ must be either a query transition or an update transition, it is easy to see that $<_1 = \emptyset$ and $q_1$ satisfies properties $P_1$, $P_2$ and $P_3$.

\item[-] Assume that $q_i=(repD_i,msgs_i,<_i)$ satisfies properties $P_1$, $P_2$ and $P_3$. let us consider $q_{i+1}= (repD_{i+1},msgs_{i+1},<_{i+1})$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $q_{i+1}$ is obtained from $q_i$ by a query transition, then this holds obviously.

    \item[-] Else, if $q_{i+1}$ is obtained from $q_i$ by a update transition. Then we can see that $(repD_i,msgs_i,<_i) {\xrightarrow{m(a,b,r)}} (repD_{i+1},msgs_{i+1}=msgs \cup \{ (dat,r,r') \vert  r' \in RId \wedge r \neq r' \},<_{i+1} = <_i \otimes dat)$.

        Since we add messages $\{ (dat,r,r') \vert  r' \in RId \wedge r \neq r' \}$ into $msgs_i$, we can see that $P_1$ holds.

        To satisfy $P_2$ and $P_3$, we need to make newly add messages maximal w.r.t $<$ and still keep transitivity, which is done by $<_i \otimes dat$.

    \item[-] Else, $q_{i+1}$ is obtained from $q_i$ by a applying transition. Then we can see that $(repD_i,msgs_i,<_i) {\xrightarrow{apply(m=(dat,r_1,r))}} (repD_{i+1},msgs_{i+1} = msgs_i - \{ m \}, <_{i+1} = <_i \otimes m )$, where $m$ is minimal w.r.t $<_i$ among messages in $msgs_i(r)$.

        Since we use one message $m$ in this process and remove it from $msgs_i$, we can see that $P_1$ holds.

        Applying message will introduce new visibility relation. To satisfy $P_2$ and $P_3$, we need to first forget $m$, record the newly introduced visibility relation, and still keep transitivity. This is done by $<_i \otimes m$.
    \end{itemize}
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}
}





