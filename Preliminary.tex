%!TEX root = draft.tex

\section{Specifications and Consistencies}
\label{sec:specifications and consistencies}

In this section, we introduce our formation of specification. Then, we propose strong-return-value consistency, which is a sub-notion of eventual consistency of \cite{Bouajjani:2014} that strengthen the ``safety part'' specific for intuition of CRDT algorithms and ignores the ``liveness part''. 


\subsection{Specification}
\label{subsec:specification}

Given

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathbb{M}$ be a finite set of method names,

\item[-] $\mathbb{D}$ be a possibly infinite set of data domain for argument and return values,

\item[-] $\mathbb{R}$ be a finite set of replica identifiers, and

\item[-] $\mathbb{O}$ be a infinite set of operation identifiers.
\end{itemize}

\todo{Define ``operation label'' which is $m(a,b)$ and denote operation labels by $\ell$. Operation content is not a good name.}

An operation $o$ is a tuple $(x,rid,oid)$, where $x =  m(a,b) \in \mathbb{M} \times \mathbb{D} \times \mathbb{D}$ is called operation content, $rid \in \mathbb{R}$ and $oid \in \mathbb{O}$. Here $o$ is called with argument $a$ and returns $b$. Let $cont(o)$ be the operation content of operation $o$. This definition extends naturally to the case when there are more than one arguments.

\todo{Use $r$ instead of $rid$ and $i$ instead of $oid$. But be careful to not use $i$ in other contexts, for instance remove the $\forall i$ from the previous section. Keep $i$ and $j$ only for operation ids.}

CRDT has two kinds of method: query methods and update methods: Operations of query methods take effect only in one replica, while operations of update methods will be delivered to other replicas. A specification $Spec$ is a function that maps each operation content $x$ into a set of tuples $(O,<,<_{\textit{arb}},l)$, where {\color {red}$O$ is a set of update operations}, $<$ is a partial over $O$, {\color {red}$<_{\textit{arb}}$ is a partial order over $O \cup \{ o \}$ called arbitration order, where $cont(o)=x$}, and $l$ map each operation of $O$ with its operation content. 
\todo{The rest of the paragraph should be a footnote. Uninteresting details.}
Here we require that each operation in $O \cup \{ o \}$ has unique operation identifier. Such $(O,<,<_{\textit{arb}},l)$ tuples are called ($\Sigma$-labeled) partial-ordered set (poset, for short), where $\Sigma$ is a set of update operation contents contains that of $O$. Two labeled posets are isomorphic if there exists a bijection of operations that preserve operation contents, labels and orders. Here we require $Spec$ to be isomorphic closed: if $x \in Spec$ and $x$ and $y$ are isomorphic, then $y \in Spec$. Since the labeling function of poset is fixed, we could ignore it when the context is clear.

\todo{I would suggest to define specifications only for query operations. I guess that you need to include $o$ in $O$ for the updates like inserting in a list. But this is kind of ugly, so I would prefer that $O$ doesn't contain $o$}

\todo{I guess $l$ is not needed. An operation is already a label (content in your terms) with ids}

\todo{Use $\mathit{arb}$ instead of $<_{\textit{arb}}$. I told you several times, don't try to minimize the space occupied by your notations. And don't use complicated indices or superscripts.}

\todo{I don't see the "deterministic" condition: for a given tuple $(O,<,arb)$, the return value is unique.}

\todo{I think that this part about plus-minus specifications is not useful here. Give standard examples and push this discussion/examples when needed.}

Some specific specifications are called plus-minus specifications and have the following features:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] It contains two update method, one is ``plus method'' and one is ``minus method'' (The names are not fixed). Intuitively, plus method intends to insert new elements, while minus method intends to remove elements.

\item[-] When the insertion as well as removing of an item is known by all replica, it is ``equivalent'' to the situation where such insertion and removing never happens.
\end{itemize}

Let us give several examples:

\noindent {\bf Example 1. OR-set}: Observed-Remove Set (OR-set for short) \cite{Shapiro:2011,Bieniusa:2012} contains four methods: (1) $add(a,\top)$ inserts $a$ into set, (2) $rem(\top,a)$ remove $a$ from set, (3) $lookup(a, b \in \{ \textit{true}, \textit{false} \})$ checks whether $a$ is in set, and $elements(\top, S \subseteq \mathbb{D})$ returns all the elements in set with a set $S$. Here $\top$ is a specific value of $\mathbb{D}$. OR-set is a plus-minus specification, while $add$ is the ``plus method'', $rem$ is the ``minus method'', and $lookup$ and $elements$ are query methods.

\todo{Why do you need $\top$ as argument ?? If it's because you want to use operation labels for messages as well, I don't like it. Each part of the formalism should be as clear as possible, without unnecessary junk.}

Let $\Sigma_{\textit{ORS}} = \{ add(a,\top),rem(\top,a) \vert a \in \mathbb{D} \}$ be the set of contents of update operations. The specification $S_{\textit{ORS}}$ is as follows: (1) For $x=add(a,\top)$ or $x = rem(\top,a)$, $S_{\textit{ORS}}(x)$ is the set of all $\Sigma_{\textit{ORS}}$- labeled posets with $<_{\textit{arb}} = \emptyset$, (2) For $x=lookup(a,\textit{true})$ (resp., $x=lookup(a,\textit{false})$), $S_{\textit{ORS}}(x)$ is the set of all $\Sigma_{\textit{ORS}}$- labeled posets $\rho$ with $<_{\textit{arb}} = \emptyset$, such that the projection of operations of $a$ contains a maximal element labeled by $add(a,\top)$ (resp., contains no maximal element labeled by $add(a,\top)$), and (3) $S_{\textit{ORS}}(elements(\top,S))$ is the $\Sigma_{\textit{ORS}}$- labeled posets that is in $S_{\textit{ORS}}(lookup(a,\textit{true}))$ for each $a \in S$, and is in $S_{\textit{ORS}}(lookup(a,\textit{false}))$ for each $a \notin S$.

\noindent {\bf Example 2. Distributed list}: Distributed list has three methods: (1) $add(a,pos,\top)$ inserts $a$ into position $pos \in \mathbb{N}$. (2) $rem(pos,a)$ removes the item of position $pos$, which is $a$. (3) $read(\top,\Sigma^*)$ returns the list content. Here we assume that for $add$ and $rem$, $pos$ is less than the length of list seen by calling replica. Distributed list is a plus-minus specification, while $add$ is the ``plus method'', $rem$ is the ``minus method'', and $read$ is query method.

%Let $\Sigma_{\textit{list}} = \{ add(a,pos,\top),rem(\top,a) \vert a \in \mathbb{D},pos \in \mathbb{N} \}$ be the set of contents of update operations.
The specification $S_{\textit{list}}$ is defined as follows: $(O,<,<_{\textit{arb}}) \in S_{\textit{list}}(x)$, if

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $<^{-1}$ contains finite elements, $<$ is acyclic and $<_{\textit{arb}}$ is a total order of $add$ operations in $O \cup \{ o \}$, where $o \notin O$ and $o$ is in domain of $<_{\textit{arb}}$. By definition of poset we can see that $cont(o)=x$.

\item[-] We can go through operations of $O$ by first investigate minimal (w.r.t $<$) operations, and then their immediate successors (w.r.t $<$), and so on. During this process, for each operation $o'$, let $Op(o')$ be the set of $add$ operations in $<^{-1}(o') \cup \{ o' \}$ and not been deactivated by $rem$ operations in $<^{-1}(o')$ (The formal definition could be found in Appendix \ref{sec:appendix definitions of section specifications and consistencies}). Let $seq(o')$ be obtained by ordering elements of $Op(o')$ with $<_{\textit{arb}}$ order. We require each $o'$ to be correct: If $cont(o')=add(a,pos)$, then $o'$ is the $pos$-th in $seq(o')$; if $cont(o')=rem(pos,a)$, then the content of $pos$-th element of $seq(o')$ is $add(a,\_)$.

\item[-] {\color {red}Let $Op(o)$ be the set of $add$ operations in $O \cup \{ o \}$ and not been deactivated by $rem$ operations in $O$, and let $seq(o)$ be obtained by ordering elements of $Op(o)$ with $<_{\textit{arb}}$ order.} If $cont(o)=add(a,pos)$, then $o$ is the $pos$-th in $seq(o)$; if $cont(o)=rem(pos,a)$, then the content of $pos$-th element of $seq(o)$ is $add(a,\_)$; if $cont(o)=read(\top,l)$, then $l$ is the sequence of operation contents of $seq(o)$.
\end{itemize}

\todo{Give a declarative specification of the list, like for OR-set. Descriptions which look like ``imperative programs'', e.g., "We can go through operations", "During this process".}

In our definition of distributed list specification, the arbitration order works similarly as the list order of strong list specification in \cite{Attiya:2016}.





\subsection{Consistencies}
\label{subsec:consistencies}

\todo{Define a history as $(O,\mathit{ro})$ (again, forget about long indices), then an annotated history as $(O,\mathit{ro},\mathit{vis},\mathit{arb})$ (dont use $\textit{textit}$).}

An abstract trace is a tuple $(O,<_{\textit{ro}},<_{\textit{vis}},<_{\textit{arb}})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $O$ is a set of operations.

\item[-] $<_{\textit{ro}}$ is called the replica order. $\forall r \in \mathbb{R}$, $<_{\textit{ro}}$ is a irreflexive total order over operations with replica identifier $r$. $<_{\textit{ro}}$ does not relate operations with different replica identifiers. We also require that $\forall o \in O$, $<_{\textit{ro}}^{-1}(o)$ is finite.

\item[-] $<_{\textit{vis}}$ is called the visibility order. We require that $\forall o \in O$, $<_{\textit{vis}}^{-1}(o)$ is finite.

\item[-] $<_{\textit{arb}}$ is the arbitration order. {\color {red}It only relate update operations.}
\end{itemize}

\todo{Local interpretation meant something else in our previous paper. Use operation context for $(\mathit{vis}^{-1}(o),<,\mathit{arb}\downarrow (\mathit{vis}^{-1}(o)\times \mathit{vis}^{-1}(o)))$ where $<$ is defined as you say.}

Given an abstract trace $t = (O,<_{\textit{ro}}<_{\textit{vis}},<_{\textit{arb}})$ and $o \in O$, {\color {red}the local interpretation of $o$ is a tuple $li(o) = ( O_{li} ,<_{li(o)}, <_{\textit{li-arb}} )$}, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] {\color {red}$O_{li}$ is the set of update operations in $<_{\textit{vis}}^{-1}(o)$,}

\item[-] {\color {red}$<_{\textit{li-arb}}$ is the projection of $<_{\textit{arb}}$ over update operations of $<_{\textit{vis}}^{-1}(o) \cup \{ o \}$. }

\item[-] $<_{li(o)} \subseteq <_{\textit{vis}} \uparrow_{(O_{li} \times O_{li})}$ is irreflexive. {\color {red}If $o_1,o_2 \in O_{li}$, $(o_1,o_2) \in <_{\textit{vis}}$ via $o'_1,\ldots,o'_m$, and $o'_1,\ldots,o'_m \in O_{li}$, then $(o_1,o_2) \in <_{li(o)}$.} Here we say $(o_1,o_2) \in <_{\textit{vis}}$ via $o'_1,\ldots,o'_m$, if $(o_1,o'_1),(o'_1,o'_2),\ldots,(o'_{\textit{m-1}},o'_m),(o'_m,o_2) \in <_{\textit{vis}}$.

\item[-] {\color {red} $<_{li(o)}$ is determined by $<_{\textit{vis}}$ over $O_{li}$. Therefore, if $<_{\textit{vis}}^{-1}(o_1)$ and $<_{\textit{vis}}^{-1}(o_2)$ contain same set of update operations, then $<_{li(o_1)} = <_{li(o_2)}$,} where $li(o_1) = ( O_{li} ,<_{li(o_1)}, <_{\textit{li-arb1}} )$ and $li(o_2) = ( O_{li} ,<_{li(o_2)}, <_{\textit{li-arb1}} )$. This property represents the intuition of commutative of CRDT.
\end{itemize}

Let us define strong-return-value consistency (SRV consistency, for short) as follows:

\todo{Define ``an annotated history satisfying SRVC and then a history satisfying SRVC, i.e., there exists $\mathit{vis}$ and $\mathit{arb}$ such that the resulting annotated history satisfies SRVC.}

\begin{definition}[Strong-return-value consistency]
\label{definition:strong return value consistency}
Given an abstract trace $t = (O,<_{\textit{ro}},<_{\textit{vis}},<_{\textit{arb}})$ and $o \in O$, we say that $t$ is strong-return-value consistent w.r.t specification $Spec$, if there exists local interpretation $li$, such that $\textit{THINAIR} \wedge \textit{RVAL}$ hold, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{THINAIR}$: $<_{\textit{ro}} \cup <_{\textit{vis}}$ is acyclic.

\item[-] $\textit{RVAL}: \forall o \in O$, $li(o) \in Spec(cont(o))$.
\end{itemize}
\end{definition}


{\color {blue}TODO:

\begin{definition}[Weak eventual consistency \cite{Bouajjani:2014}]
\label{definition:eventual consistency}
An abstract trace $t = (O,<_{\textit{ro}},<_{\textit{vis}},<_{\textit{arb}})$ is called weak eventual consistency w.r.t a specification $Spec$, if there exists local interpretation $li$, such that $\textit{THINAIR} \wedge \textit{RVAL} \wedge \textit{WEAKEVENTUAL}$ hold, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{WEAKEVENTUAL}$: $\forall o \in O, \{ o' \vert (o,o') \notin <_{\textit{vis}} \}$ is finite.
\end{itemize}
\end{definition}

}














\forget
{
\section{Strong Return Value Consistency}
\label{sec:strong return value consistency}

In this section, we introduce the definition of eventual consistency in \cite{Bouajjani:2014}, and related notation.


\subsection{Trace}
\label{subsec:trace}

Given a finite set $M$ of method names, a possibly infinite set $D$ of data domain, a finite set $RId=\{1,\ldots,n\}$ of replica identifiers and a possibly infinite set $OId$ of operation identifiers, an operation is a tuple $o=(m,a,b,rid,oid)$, where $m \in M$, $a,b \in D$, $rid \in RId$ and $oid \in OId$. Here $o$ represents that it calls method $m$ with argument $a$ and obtains return values $b$, and it happens on replica $rid$. This definition extends naturally to the case when there are more than one arguments.

A partial-ordered set (poset, for short) is a tuple $(A,<)$ contains a possibly infinite set $A$ and a partial-order $<$ of $A$. A trace $\tau$ is a possibly infinite poset $(Os,ro)$, where
\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $Os$ is a set of operations. Here we assume that a trace does not contain two operations with the same identifier.

\item[-] $ro$ is called the replica order. For each replica identifier $k$, $ro$ is a irreflexive total order over operations with replica identifier $k$. It does not relate operations with different replica identifiers. We also require that for each $o \in Os$, $ro^{-1}(o)$ is a finite set.
\end{itemize}

A poset $(A_1,<_1)$ is called a prefix of a poset $(A_2,<_2)$, denoted by $(A_1,<_1) \preceq (A_2,<_2)$, if $A_1 \subseteq A_2$, $<_1$ is the intersection of $<_2$ and $A_1 \times A_1$, and $A_1 = <_2^{-1}(A)$. A $\Sigma$-labeled poset is a tuple $(A,<,l)$, where $(A,<)$ is a poset and $l:A \rightarrow \Sigma$ is a function that labels each element of $A$ with an element in $\Sigma$. The set of all $\Sigma$-labeled poset is denoted as $PoSet_{\Sigma}$.


\subsection{Eventual Consistency}
\label{subsec:eventual consistency}

For a set $A$, let $P(A)$ denotes the set of all subsets of $A$. Let $\Sigma(M,D) = \{ m(a,b) \vert m \in M, a,b, \in D \}$. A specification $Spec$ is a function $Spec: \Sigma(M,D) \rightarrow P(PoSet_{\Sigma(M,D)})$.

Given a trace $\tau = (Os,ro)$, for each operation $o \in Os$, its local interpretation, denoted $li(o) = (O_o,<_o)$, is a poset of operations. The local interpretation defines another relation between operations, called executed-before and denoted by $eb$. $(o,o') \in eb$, if $o'$ is in the local interpretation of $o$. We say that the return value of an operation $o = (m,a,b,rid,oid) \in Os$ is correct, if the labeled poset defined by $li(o)$, where every operation $(m',a',b',rid',oid')$ is labeled by $(m',a',b')$, belongs to $Spec(m(a,b))$. Then, a trace $\tau$ is safe if the return value of every operations of $\tau$ is correct.

Given trace $\tau$, its global interpretation is a partial-order over all the operations of $\tau$.

\begin{definition}[Eventual Consistency \cite{Bouajjani:2014}]
\label{definition:eventual consistency}
A trace $\tau = (Os,ro)$ is called eventual consistency w.r.t a specification $Spec$, if:

$\exists gi$ an irreflexive partial order over $Os$, such that $\forall o \in Os$, $\exists li[o]$ an irreflexive poset, such that

$\textit{GIpf} \wedge \textit{THINAIR} \wedge \textit{RVAL} \wedge \textit{EVENTUAL}$ hold.
\end{definition}

Here, $GIpf$, $THINAIR$, $RVAL$ and $EVENTUAL$ is given as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{GIpf}$: $\forall o \in Os$, $<^{-1}_{gi}(o)$ is finite.

\item[-] $\textit{THINAIR}$: $eb \cup ro$ is acyclic.

\item[-] $\textit{RVAL}$: $\forall o = (m,a,b,rid,oid) \in Os$, $li_{\Sigma(M,D)}(o) \in Spec(m,a,b)$. Here $li_{\Sigma(M,D)}(o)$ is obtained from $li(o)$ by labeling each $(m',a',b',rid',oid')$ with $(m,a,b)$.

\item[-] $\textit{EVENTUAL}$: For any finite prefix $P$ of the poset $(Os,gi)$, $\{ o \vert o \in Os, P \npreceq li(o) \}$ is finite.
\end{itemize}
}
