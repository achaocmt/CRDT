%!TEX root = draft.tex

\section{Simulation and Refinement}
\label{sec:simulation and refinement}

An labeled transition system (LTS, for short) is a tuple $A = (Q,\Sigma,\rightarrow,q_0)$, where $Q$ is a set of states, $\Sigma$ is an alphabet of transition labels, $\rightarrow \subseteq Q \times \Sigma \times Q$ is a transition relation and $q_0$ is the initial state. A execution of $A$ is a sequences of transitions and states starting from the initial state $q_0$, and a trace is a sequence of transition labels of an execution. We say that $A$ is deterministic, if for each state $q$ and each transition label $\alpha$, $q$ has at most one $\rightarrow$ successor with transition label $\alpha$.



%A execution of $A$ is a sequence $\alpha_1 \cdot \ldots \cdot \alpha_k \in \Sigma^*$, such that $\exists q_1,\ldots,q_k \in Q$, $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots {\xrightarrow{\alpha_k}} q_k$. We say that $A$ is deterministic, if $\forall q \in Q$ and $\forall \alpha \in \Sigma$, there exists at most one $q' \in Q$, such that $q {\xrightarrow{\alpha}} q'$.

%\todo{Define execution as $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots {\xrightarrow{\alpha_k}} q_k$ and trace as $\alpha_1 \cdot \ldots \cdot \alpha_k$, extracted from an execution. Extend the notation $\xrightarrow{\alpha_1}$ to words instead of letters.}

%\todo{Don't use $\forall$ and $\exists$ in a textual description, but only in formulas}

Given two LTS $A_1 = (Q_1,\Sigma_1,\rightarrow_1,q_{0}^1)$ and $A_2 = (Q_2,\Sigma_2,\rightarrow_2,q_{0}^2)$ and two functions $f_s: Q_1 \times Q_2 \times \Sigma_1 \rightarrow \Sigma_2$ and $f_t:\Sigma_1^* \rightarrow \Sigma_2$, we define our simulation and refinement relations as follows:

%Given two LTS $A = (Q_A,\Sigma_A,\rightarrow_A,q_{0A})$ and $B = (Q_B,\Sigma_B,\rightarrow_B,q_{0B})$ with alphabet $\Sigma_A$ and $\Sigma_B$, respectively. Given functions $f_s: Q_A \times Q_B \times \Sigma_A \rightarrow \Sigma_B$ and $f_t:\Sigma_A^* \rightarrow \Sigma_B$, we define our simulation and refinement relations as follows:

%\todo{Use $A_1$ and $A_2$ instead of $A$ and $B$, so that all the components are indexed by 1,2, except for $q_0$ which becomes $q_0^{1/2}$.}

\begin{definition}[$f_s$-Simulation]
\label{definition:fs simulation}
Relation $R \subseteq Q_1 \times Q_2$ is a $f_s$-simulation relation, if whenever $(q_1,q_2) \in R \wedge q_1 {\xrightarrow{\alpha}}_1 q'_1$,
%A $f_s$-simulation relation $R \subseteq Q_A \times Q_B$ is a relation that satisfies: If $(q_a,q_b) \in R \wedge q_a {\xrightarrow{\alpha}}_A q'_a$ for some $q_a$, then
\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $f_s(q_1,q_2,\alpha) \neq \epsilon$, then $q_2 {\xrightarrow{f_s(q_1,q_2,\alpha)}}_1 q'_2 \wedge (q'_1,q'_2) \in R$.

\item[-] If $f_s(q_1,q_2,\alpha) = \epsilon$, then $(q'_1,q_2) \in R$.
\end{itemize}
\end{definition}

%\todo{Again, use indexing with 1,2}

\begin{definition}[refinement w.r.t $f_t$]
\label{definition:ft refinement}
$A_2$ refines $A_1$ w.r.t $f_t$, if for each trace $t_1 = \alpha_1 \cdot \ldots \cdot \alpha_k$ of $A_1$, $t_2 = f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)$ is an execution of $A_2$.
\end{definition}

%\todo{$B$ $f_t$-refines $A$ to be rewritten to ``$B$ refines $A$ w.r.t. $f_t$''}

%\todo{Give a name to the property $P_{(f_s,f_t)}$, for instance: we say that $f_s$ and $f_t$ are compatible ... }

We say that $f_s$ and $f_t$ are compatible, if for each deterministic $A_2$, the following holds: For each execution %\todo{execution} 
$q_{0}^1 {\xrightarrow{\alpha_1}}_1 q_{1}^1 \ldots {\xrightarrow{\alpha_k}}_1 q_{k}^1$ of $A_1$ and each $1 \leq u \leq k$, we have $f_t(\alpha_1 \cdot \ldots \cdot \alpha_{u+1}) = f_s(q_{u}^1,q_{u}^2,\alpha_{u+1})$, here $q_u^2$ is a state obtained by $q_{0}^2 {\xrightarrow{f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_u) }}_2 q_u^2$. %\todo{write it explicitly using the extension of $\xrightarrow{\alpha_1}$ to words}
The following theorem states that $f_s$ and $f_t$ are compatible, $f_s$-simulation is equivalent to refinement w.r.t $f_t$. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section simulation and refinement} and is similar to that in \cite{Abadi:1991,Lynch:1995}.

%If $B$ is deterministic, then we defined a property $P_{(f_s,f_t)}$ as follows: For each transitions \todo{execution} $q_{0A} {\xrightarrow{\alpha_1}}$ $q_{1A} \ldots {\xrightarrow{\alpha_k}} q_{kA}$ of $A$, $\forall 1 \leq i < k$, $f_t(\alpha_1 \cdot \ldots \cdot \alpha_i \cdot \alpha_{i+1}) = f_s(q_{iA},q_{iB},\alpha_{i+1})$, where $q_{iB}$ is obtained from $q_{0B}$ by doing $f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_i)$ transitions \todo{write it explicitly using the extension of $\xrightarrow{\alpha_1}$ to words}. The following theorem states that when $P_{(f_s,f_t)}$ holds, $f_s$-simulation is equivalent to $f_t$-refinement. Its proof can be found in Appendix \ref{sec:appendix definitions and proofs of section simulation and refinement} and is similar to that in \cite{Abadi:1991,Lynch:1995}.

\begin{theorem}
\label{theorem:equivalence of our simulation and refinement}
Given an LTS $A_1$ and a deterministic LTS $A_2$ and functions $f_s,f_t$, such that $f_s$ and $f_t$ are compatible. $A_2$ refines $A_1$ w.r.t $f_t$, if and only if there exists a $f_s$-simulation relation between $A_1$ and $A_2$.
\end{theorem}

































\forget
{
\section{Simulation Relation}
\label{sec:simulation relation}

In this section, we give our simulation relation between a implementation $\llbracket imp \rrbracket$ and a reference implementation (with causal delivery) $A$. For plus-minus specification and its compacted reference implementation $A'$, we give our simulation relation between $\llbracket imp \rrbracket$ and $A'$. For both simulation relations, we prove that they are sound and complete for refinement checking.

Given $\llbracket imp \rrbracket = (Q_{imp},\Sigma_{imp},\rightarrow_{imp},q_{0imp})$ and $RImp(Spec) = (Q_s,\Sigma_s,vis,q_{0s},li,\rightarrow_s,livReq)$, we say that $R \subseteq Q_{imp} \times Q_s$ is a simulation relation, if given $(q_i,q_s) \in R$

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_i {\xrightarrow{m(a,b,r)}}_{imp} q'_i$, then $q_s {\xrightarrow{m(a,b,r)}}_s q'_s$ and $(q'_i,q'_s) \in R$.

\item[-] If $q_i {\xrightarrow{apply(m)}}_{imp} q'_i$, then $q_s {\xrightarrow{addDel(o,r)}}_s q'_s$ and $(q'_i,q'_s) \in R$. Here $o$ and $r$ are obtained as follows: Assume $m=(\_,r',r)$ is the $i-th$ among messages of $q_i$ with source replica $r'$ and destination replica $r$ w.r.t $<_{sd}$. Then, $o$ is the $i-th$ among operations of $q_s$ which happens on replica $r'$ and not visible to replica $r$ w.r.t $ro$.
\end{itemize}




\forget{
Given $\llbracket imp \rrbracket = (Q_{imp},\Sigma_{imp},\rightarrow_{imp},q_{0imp})$ (not assuming causal delivery) and $RImp(Spec) = (Q_s,\Sigma_s,vis,q_{0s},li,\rightarrow_s,livReq)$, we say that $R \subseteq Q_{imp} \times Q_s$ is a simulation relation, if given $(q_i,q_s) \in R$ where $q_i = (repD,msgs,<_{roi})$ and $q_s = (uO,ro,del)$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Let $MsgToOp(q_i) = \{ o \vert \exists m = (dat,\_,\_) \in msgs, o=op(dat) \}$ be the set of operations of messages in $q_i$. Let $AOpS(q_s) = \{ o \vert o \in uO, \exists r, \neg (o {\xrightarrow{vis}} r) \}$ be the set of operations in $q_s$ that are not delivered into all replicas. Given $r \in RId$, let $MsgToOp(q_i)(r) = \{ o \vert \exists m = (dat,\_,r) \in msgs, o=op(dat) \}$ and $AOpS(q_s)(r) = \{ o \vert o \in uO, \neg (o {\xrightarrow{vis}} r) \}$. We require that,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $\forall r \in RId$, $\vert MsgToOp(q_i)(r) \vert = \vert AOpS(q_s)(r) \vert$.

    \item[-] There is a function $f_{(q_i,q_s)}$ that maps the $i-th$ op of $MsgToOp(q_i)(r)$ w.r.t $<_{roi}$ into the $i-th$ op of $AOpS(q_s)(r)$ w.r.t $ro$ for each $i$. Moreover, $o_1 = OpMsgI(q_i)(r_1)$, $o_2 = OpMsgI(q_i)(r_2)$, $r_1 \neq r_2$, and $o_1$ and $o_2$ are mapped from same $dat$, if and only if $f_{(q_i,q_s)}(o_1)=f_{(q_i,q_s)}(o_2)$. We can see that such $f_{(q_i,q_s)}$ is unique if it exists.
    \end{itemize}

\item[-] If $q_i {\xrightarrow{m(a,b,r)}}_{imp} q'_i$, then $q_s {\xrightarrow{m(a,b,r)}}_s q'_s$ and $(q'_i,q'_s)$.

\item[-] If $q_i {\xrightarrow{apply(m)}}_{imp} q'_i$, $m=(dat,\_,r)$ and $f_{(q_i,q_s)}(op(dat))=o$, then $q_s {\xrightarrow{addDel(o,r)}}_s q'_s$ and $(q'_i,q'_s)$.
\end{itemize}

}




We say that a transition system is deterministic, if for each state $q$ and transition label $\alpha$, from $q$ there is at most one transition with label $\alpha$. {\color {red}It is safe to assume that when constructing reference implementation $RImp(Spec)$, in update operation transitions $q_s {\xrightarrow{m(a,b,r)}}_s q'_s$, we permit only one possible identifier of the newly added operation of $q'_i$. For example, each replica has a counter for generating unique identifier of operations. In this way, it is obvious that $RImp(Spec)$ is deterministic.}

Given a sequence $t_{imp} = \alpha_1 \cdot \ldots \in \llbracket imp \rrbracket$ and a sequence $t_s = \beta_1 \cdot \ldots \in RImp(Spec)$, we say that $t_{imp}$ and $t_s$ correspond, if

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\alpha_i$ is an operation, then $\beta_i = \alpha_i$.

\item[-] Else, $\alpha_i = apply(m)$ and $\beta_i = addDel(o,r)$. Here $o$ and $r$ are obtained as follows: Assume after doing $\alpha_1 \cdot \ldots \cdot \alpha_{i-1}$, $m=(\_,r',r)$ is the $i-th$ among ``messages with source replica $r'$ and destination replica $r$ and still not applied'' w.r.t the occurring order of $t_{imp}$. {\color {red}Here we assume that in $\llbracket imp \rrbracket$, the set of newly generated messages could be seen as ghost variable of $m(a,b,r)$ transitions.}

    Then, after doing $\beta_1 \cdot \ldots \cdot \beta_{i-1}$, $o$ is the $i-th$ among ``operations which happens on replica $r'$ and not visible to replica $r$'' w.r.t the occurring order of $t_s$. {\color {red} Here we assume that in $RImp(Spec)$, the newly generated operation could be seen as ghost variable of $m(a,b,r)$ transitions.}
\end{itemize}

We can prove that, given $t_{imp}$, there exists at most one $t_s$, such that $t_{imp}$ and $t_s$ correspond. The reason is that, (1) $RImp(Spec)$ is deterministic, and (2) to deal with $apply(m)$ transition, there is only one possible selection of operation $o$.

We say that $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$, if $\forall t_{imp} \in \llbracket imp \rrbracket$, $\exists t_s \in RImp(Spec)$, such that $t_{imp}$ and $t_s$ correspond. It is obvious that our simulation relation implies trace inclusion. Since $RImp(Spec)$ is deterministic, similarly as that of \cite{Abadi:1991,Lynch:1995}, we could prove that the opposite direction also holds. Therefore, our simulation relation is a sound and complete method to prove trace refinement, as states by the following theorem:

\begin{theorem}
\label{theorem:equivalence of our simulation relation and sequence inclusion}
$RImp(Spec)$ trace refines $\llbracket imp \rrbracket$, if and only if there exists a simulation relation between $\llbracket imp \rrbracket$ and $RImp(Spec)$.
\end{theorem}



When we consider implementation and reference implementation with causal delivery, above definitions and lemmas still hold. The reason is that, we could easily obtain $<_{sd}$ order from $<$ order in state of implementation.




\subsection{Simulation Relation for Plus-Minus Specification}
\label{subsec:simulation relation for plus-minus specification}

Let $\llbracket imp \rrbracket_{pm}$ be obtained from $\llbracket imp \rrbracket$ by making applying of some messages invisible. Formally,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state is of the form $(repD,msgs,<_{sd})$. We change $msgs$ such that there are two kinds of messages: $(dat,r,r')$ and $(data,r,r')_{inv}$.

\item[-] $\Sigma = \{ \epsilon, m(a,b,r), apply(msg) \vert m \in M, a,b \in D, r \in RId, msg \in Msg \}$ is the set of transition labels.

\item[-] When doing operation transitions, some message is transformed into invisible. For example, if $(redD,msgs,<_{sd}) {\xrightarrow{m(a,b,r)}} (redD',msgs',<'_{sd})$ is a transition of $\llbracket imp \rrbracket$, then $(redD,msgs,<_{sd}) {\xrightarrow{m(a,b,r)}} (redD',f(msgs'),<'_{sd})$ is a transition of $\llbracket imp \rrbracket_{pm}$. Here $f(msgs')$ is obtained from $msgs'$ by adding subfix $inv$ into some messages.
\item[-] When applying a message $(\_,\_,\_)$, same as before.

When applying a message $(\_,\_,\_)_{inv}$, use $\epsilon$ as transition label.
\end{itemize}


Given $\llbracket imp \rrbracket_{pm} = (Q_{imp},\Sigma_{imp},\rightarrow_{imp},q_{0imp})$ and $CRImp(Spec) = (Q_s,\Sigma_s,vis,q_{0s},li,\rightarrow_s,livReq)$, we say that $R \subseteq Q_{imp} \times Q_s$ is a weak simulation relation, if given $(q_i,q_s) \in R$

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_i {\xrightarrow{m(a,b,r)}}_{imp} q'_i$, then $q_s {\xrightarrow{m(a,b,r)}}_s q'_s$ and $(q'_i,q'_s) \in R$.

\item[-] If $q_i {\xrightarrow{apply(m)}}_{imp} q'_i$, $m=(\_,r',r)$, then $q_s {\xrightarrow{addDel(o,r)}}_s q'_s$ and $(q'_i,q'_s) \in R$. Here $o$ is obtained as follows: Assume $m$ is the $i-th$ among messages of $q_i$ with source replica $r'$, destination replica $r$ and are visible w.r.t $<_{sd}$. Then, $o$ is the $i-th$ among operations of $q_s$ which happens on replica $r'$ and not visible to replica $r$ w.r.t $ro$.

\item[-] If $q_i {\xrightarrow{apply(m)}}_{imp} q'_i$, $m=(\_,r',r)_{inv}$, then $(q'_i,q_s) \in R$.
\end{itemize}


Given a sequence $t_{imp} = \alpha_1 \cdot \ldots \in \llbracket imp \rrbracket_{pl}$ and a sequence $t_s = \beta_1 \cdot \ldots \in CRImp(Spec)$, we say that $t_{imp}$ and $t_s$ correspond, if

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\alpha_i$ is an operation, then $\beta_i = \alpha_i$.

\item[-] Else, if $\alpha_i = apply(m=(\_,r',r))$ and $\beta_i = addDel(o,r)$. Here $o$ is obtained as follows: Assume after doing $\alpha_1 \cdot \ldots \cdot \alpha_{i-1}$, $m$ is the $i-th$ among ``messages with source replica $r'$ and destination replica $r$ and still not applied and are visible'' w.r.t the occurring order of $t_{imp}$. Then, after doing $\beta_1 \cdot \ldots \cdot \beta_{i-1}$, $o$ is the $i-th$ among ``operations which happens on replica $r'$ and not visible to replica $r$'' w.r.t the occurring order of $t_s$.

\item[-] Else, $\alpha_i = apply(m=(\_,r',r)_{inv})$ and $\beta_i = \epsilon$.
\end{itemize}

We say that $CRImp(Spec)$ weak trace refines $\llbracket imp \rrbracket_{pl}$, if $\forall t_{imp} \in \llbracket imp \rrbracket_{pl}$, $\exists t_s \in CRImp(Spec)$, such that $t_{imp}$ and $t_s$ correspond. It is obvious that our weak simulation relation implies trace inclusion. Since $RImp(Spec)$ is deterministic, similarly as that of \cite{Abadi:1991,Lynch:1995}, we could prove that the opposite direction also holds. Therefore, our weak simulation relation is a sound and complete method to prove trace refinement, as states by the following theorem:

\begin{theorem}
\label{theorem:equivalence of our simulation relation and sequence inclusion for add-plus specification and its compacted reference implementation}
$CRImp(Spec)$ trace refines $\llbracket imp \rrbracket_{pl}$, if and only if there exists a weak simulation relation between $\llbracket imp \rrbracket_{pl}$ and $CRImp(Spec)$.
\end{theorem}
}

