%!TEX root = draft.tex

\section{Definitions and Proofs of Section \ref{sec:reference implementation}}
\label{sec:appendix definitions and proofs of section reference implementation}

{\noindent \bf Theorem \ref{theorem:histories of reference implementation are SRV consistent}}: For each $h \in \mathit{his}(\mathit{RImp}(\mathit{Spec}))$, $h$ is CRVC consistent w.r.t $\mathit{Spec}$.

\begin {proof}

Assume $\mathit{RImp}(\mathit{Spec}) = (Q,\Sigma,\rightarrow,q_0)$. We prove this theorem by proving that, given a trace $t = \alpha_1 \cdot \ldots$ of $\mathit{RImp}(\mathit{Spec})$, its annotated history $\mathit{ah}_t$ is SRVC consistent w.r.t $\mathit{Spec}$.

Let $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots$ be the execution of $t$. Let $\mathit{ah}_t = (O_t,\mathit{vis}_t,\mathit{arb}_t)$. According to the construction of $\mathit{ah}_t$, it is easy to see that $\mathit{ro}_t \subseteq \mathit{vis}_t \wedge \mathit{vis}_t$ is acyclic.

We need to prove that, there exists function $ctxt$, such that $\forall o \in O_t$, $ctxt(o) = (O_o,<_o,arb_o) \in Spec(lab(o))$. Assume $o$ is generated with the transition $q_k = (O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k)$ ${\xrightarrow{\alpha_{k+1}}} q_{k+1}$. It is easy to see that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $O_k$ is the set of update operations in $\alpha_1 \cdot \ldots \cdot \alpha_k$,

\item[-] $(\mathit{ro}_k \cup (\mathit{del}_k \cdot \mathit{ro}_k)) \uparrow_{ Q_k }$ is the visibility relation of update operations of $\alpha_1 \cdot \ldots \cdot \alpha_k$,

\item[-] $\mathit{arb}_k$ is the projection of $arb_t$ into $O_k \times O_k$.
\end{itemize}

By the definition of transition relation of $\mathit{RImp}(\mathit{Spec})$, we can always choose $ctxt(o)$ to be $f_{\mathit{ctxt}}((O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k),o)$. It is easy to see that $ctxt(o)$ to be $ctxt(o) = f_{\mathit{ctxt}}((O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k),o)$ holds as required. This completes the proof of this theorem. $\qed$
\end {proof}





Let $\mathit{trace}(A)$ be the set of traces of LTS $A$. The following lemma states that the trace of $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$ is the set of traces of $\mathit{RImp}(\mathit{Spec})$ that satisfies causal delivery.

\begin{lemma}
\label{lemma:RImpcdSpec contains all the sequences of RImpSpec that are causal delivery}
$\mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} ) = \{ t \vert t \in \mathit{trace}( \mathit{RImp}(\mathit{Spec}) ) \wedge t$ satisfies causal delivery $\}$.
\end{lemma}

\begin {proof}

Let us prove the $\subseteq$ direction. We prove it by contradiction. Assume $\exists t =\alpha_1 \cdot \ldots \cdot \alpha_k \in \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$ and $t$ does not satisfy causal delivery. Then there exists operations $o_1,o_2$ and replica $r$, such that $(o_1,o_2) \in \mathit{hb}$ and in $t$, when $o_2$ is delivered to replica $r$, $o_1$ has not been delivered to replica $r$ yet.

Let $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots {\xrightarrow{\alpha_k}} q_k$ be the execution of $t$. Assume that for each $u$, $q_u = (O_u,\mathit{ro}_u,\mathit{del}_u,\mathit{arb}_u)$. It is easy to prove by induction that, for each $u$, when both $o_1$ and $o_2$ are in $O_u$, $(o_1,o_2) \in \mathit{vis}_u = (\mathit{ro}_u \cup \mathit{del}_u)^*$. Let $\alpha_v = \mathit{addDel}(o_2,r)$. Then, we can see that $(o_1,o_2) \in \mathit{vis}_{v-1} = (\mathit{ro}_{v-1} \cup \mathit{del}_{v-1})^*$, and $o_1,o_2 \notin \mathit{visTo}(O_{v-1},r,\mathit{vis}_{v-1})$. By our definition of transition relation of $\mathit{RImp}(\mathit{Spec})$, we could not launch $\mathit{addDel}(o_2,r)$ transition from $q_{u-1}$, contradiction happens.

Let us prove the $\supseteq$ direction. We prove its contrapositive. Assume that $t_1 =\alpha_1 \cdot \ldots \cdot \alpha_k \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$, we need to prove that $t_1 \notin \{ t \vert t \in \mathit{trace}( \mathit{RImp}(\mathit{Spec}) ) \wedge t$ satisfies causal delivery $\}$. This holds trivially when $t_1 \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec}) )$.

For the case when $t_1 \in \mathit{trace}( \mathit{RImp}(\mathit{Spec}) )$. Since $t_1 \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$, there exists a number $u$, such that $\alpha_1 \cdot \ldots \cdot \alpha_u \notin \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$ and $\alpha_1 \cdot \ldots \cdot \alpha_{u-1} \in \mathit{trace}( \mathit{RImp}(\mathit{Spec})_{\mathit{cd}} )$. Since $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$ is deterministic, it is easy to see that $\alpha_u$ is a $\mathit{addDel}$ transition and it violates the transition condition of $\mathit{RImp}(\mathit{Spec})_{\mathit{cd}}$. Assume that $q_{\mathit{u-1}} = (O_{u-1},\mathit{ro}_{u-1},\mathit{del}_{u-1},\mathit{arb}_{u-1})$. Then, there must exists $o_3,o_4 \in O_{u-1}$, such that $(o_3,o_4) \in \mathit{hb}_{u-1}$, $o_3,o_4 \notin \mathit{visTo}(O_{u-1},r,\mathit{vis}_{u-1})$, and $\alpha_u = \mathit{addDel}(o_4,r)$. This violates causal delivery. $\qed$
\end {proof}













\section{Definitions and Proofs of Section \ref{sec:succinct reference implementations of collection data types}}
\label{sec:appendix definitions and proofs of section succinct reference implementations of collection data types}

The following two lemma states that, $\mathit{frg}$ has some feature of weak bi-simulation.

\begin{lemma}
\label{lemma:RImpSpec is simulated by SRimpSpec}
If $q'_1 = \mathit{frg}(q_1,S)$ and $q_1 {\xrightarrow{\alpha}}_r q_2$ in $\mathit{RImp}(\mathit{Spec})$, then $\exists q'_2$, such that $q'_1 {\xrightarrow{\alpha}'}_r q'_2$ in $\mathit{RImp}(\mathit{Spec})$ and $q'_2 = \mathit{frg}(q_2,S)$. If $\alpha = \mathit{addDel}(o,r) \wedge o \in S$, then $\alpha' = \epsilon$ and $q'_2 = q'_1$; Else, if $\alpha$ is of query method or $\alpha = \mathit{addDel}(o,r)$, then $\alpha' = \alpha$; Else, $\alpha'$ is obtained from $\alpha$ by removing operations of $S$ from arbitration order.
\end{lemma}

\begin {proof}

Assume $q_1 = (O_1,\mathit{ro}_1,\mathit{del}_1,\mathit{arb}_1)$, and $q'_1 = (O'_1,\mathit{ro}'_1,\mathit{del}'_1,\mathit{arb}'_1)$. Let us consider all possible cases of transition:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\alpha = \mathit{addDel}(o,r) \wedge o \in S$: by definition it is obvious that $q'_1 = \mathit{frg}(q_2,S)$.

\item[-] $\alpha = \mathit{addDel}(o,r) \wedge o \notin S$: We can see that $(o,r)\notin visTo(O_1,r,\mathit{vis}_1)$. Since $\mathit{frg}$ keeps visibility relation for non-$S$ operations, we can see that $(o,r)\notin visTo(O'_1,r,\mathit{vis}'_1)$. Therefore, we have $ (O'_1,\mathit{ro}'_1,\mathit{del}'_1,\mathit{arb}'_1) {\xrightarrow{addDel(o,r)}}_r q'_2 = (O'_1,\mathit{ro}'_1,\mathit{del}'_1 \cup \{ (o,r) \},\mathit{arb}'_1)$ and it is obvious that $q'_2 = \mathit{frg}(q_2,S)$.

\item[-] $\alpha = (\ell,r,\_)$ is of a query method: Let annotated history $\mathit{ah}_1 = (O_{\mathit{ah1}},\mathit{vis}_{\mathit{ah1}},\mathit{arb}_{\mathit{ah1}})$, where $O_{\mathit{ah1}} = O_1 \cup \{ o \}$, $o \notin O$, $\mathit{lab}(o)=\ell$, $\mathit{vis}_{\mathit{ah1}}$ is obtained from replica order $\mathit{ro}_1 \cup \{ (o',o) \vert o' = (\_,r,\_) \in O_1\}$ and delivery order $\mathit{del}_1$, and $\mathit{arb}_{\mathit{ah1}} = \mathit{arb}_1$. It is easy to see that $S$ can be forgotten from the set of states of $\mathit{ah}_1$, and let annotated history $\mathit{ah}_2$ be obtained by $\mathit{ah}_2 = \mathit{frg}(\mathit{ah}_1,S)$.

    Let $y'$ be the operation context of $\mathit{ah}_1$ and $o$, and let $y''$ be the operation context of $\mathit{ah}_2$ and $o$. By transition $q_1 {\xrightarrow{\alpha}}_r q_2$ we ensure that $y' \in \mathit{Spec}(\ell)$. By the property of collection specification, we can see that $y'' \in \mathit{Spec}(\ell)$. This implies that $(O'_1,\mathit{ro}'_1,\mathit{del}'_1,\mathit{arb}'_1) {\xrightarrow{(m,a,b,r,\mathit{arb}'_1)}}_r q'_2 = (O'_1,\mathit{ro}'_1,\mathit{del}'_1,\mathit{arb}'_1)$ and it is obvious that $q'_2 = \mathit{frg}(q_2,S)$.

\item[-] $\alpha = (\ell,r,\_)$ is of a update method: Let annotated history $\mathit{ah}_1 = (O_{\mathit{ah1}},\mathit{vis}_{\mathit{ah1}},\mathit{arb}_{\mathit{ah1}})$, where $O_{\mathit{ah1}} = O_1 \cup \{ o \}$, $o \notin O$, $\mathit{lab}(o)=\ell$, $\mathit{vis}_{\mathit{ah1}}$ is obtained from replica order $\mathit{ro}_1 \cup \{ (o',o) \vert o' = (\_,r,\_) \in O_1\}$ and delivery order $\mathit{del}_1$, and $\mathit{arb}_{\mathit{ah1}}$ equals the arbitration order of $q_2$. It is easy to see that $S$ can be forgotten from the set of states of $\mathit{ah}_1$, and let annotated history $\mathit{ah}_2$ be obtained by $\mathit{ah}_2 = \mathit{frg}(\mathit{ah}_1,S)$.

    Let $y'$ be the operation context of $\mathit{ah}_1$ and $o$, and the arbitration order of $y'$ is the projection of arbitration order of $q_2$ into operations of $y'$. Let $y''$ be the operation context of $\mathit{ah}_2$ and $o$, and the arbitration order of $y''$ is the projection of the arbitration order of $y'$ into operations of $y''$. By transition $q_1 {\xrightarrow{\alpha}}_r q_2$ we ensure that $y' \in \mathit{Spec}(\ell)$. By the property of collection specification, we can see that $y'' \in \mathit{Spec}(\ell)$. This implies that $(O'_1,\mathit{ro}'_1,\mathit{del}'_1,\mathit{arb}'_1) {\xrightarrow{(m,a,b,r,\mathit{arb}'_2)}}_r q'_2 =  (O'_1 \cup \{ o \},\mathit{ro}' \oplus o ,\mathit{del}' \oplus o,\mathit{arb}'_2)$, where $\mathit{arb}'_2$ is the projection of arbitration order of $q_2$ into operations of $q'_2$. It is obvious that $q'_2 = \mathit{frg}(q_2,S)$.
\end{itemize}
This completes the proof of this lemma. $\qed$
\end {proof}



\begin{lemma}
\label{lemma:SRImpSpec is simulated by RimpSpec}
If $q'_1 = \mathit{frg}(q_1,S)$ and $q'_1 {\xrightarrow{\alpha}'}_r q'_2$ in $\mathit{RImp}(\mathit{Spec})$, then $\exists q_2$, such that $q_1 {\xrightarrow{\alpha}}_r q_2$ in $\mathit{RImp}(\mathit{Spec})$ and $q'_2 = \mathit{frg}(q_2,S)$. If $\alpha'$ is of query method or $\alpha' = \mathit{addDel}(o,r)$, then $\alpha = \alpha'$; Else, $\alpha$ is a transition label such that $\alpha'$ is obtained from $\alpha$ by removing operations of $S$ from arbitration order.
\end{lemma}

\begin {proof}

Assume $q'_1 = (O'_1,\mathit{ro}'_1,\mathit{del}'_1,\mathit{arb}'_1)$, and $q_1 = (O_1,\mathit{ro}_1,\mathit{del}_1,\mathit{arb}_1)$. Let us consider all possible cases of transition:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\alpha' = \mathit{addDel}(o,r)$: We can see that $(o,r)\notin visTo(O'_1,r,\mathit{vis}_1)$. Since $\mathit{frg}$ keeps visibility relation for non-$S$ operations, we can see that $(o,r)\notin visTo(O_1,r,\mathit{vis}'_1)$. Therefore, we have $ (O_1,\mathit{ro}_1,\mathit{del}_1,\mathit{arb}_1) {\xrightarrow{addDel(o,r)}}_r q_2 = (O_1,\mathit{ro}_1,\mathit{del}_1 \cup \{ (o,r) \},\mathit{arb}_1)$ and it is obvious that $q'_2 = \mathit{frg}(q_2,S)$.

\item[-] $\alpha' = (\ell,r,\_)$ is of a query method: Let annotated history $\mathit{ah}_1 = (O_{\mathit{ah1}},\mathit{vis}_{\mathit{ah1}},\mathit{arb}_{\mathit{ah1}})$, where $O_{\mathit{ah1}} = O_1 \cup \{ o \}$, $o \notin O$, $\mathit{lab}(o)=\ell$, $\mathit{vis}_{\mathit{ah1}}$ is obtained from replica order $\mathit{ro}_1 \cup \{ (o',o) \vert o' = (\_,r,\_) \in O_1\}$ and delivery order $\mathit{del}_1$, and $\mathit{arb}_{\mathit{ah1}} = \mathit{arb}_1$. It is easy to see that $S$ can be forgotten from the set of states of $\mathit{ah}_1$, and let annotated history $\mathit{ah}_2$ be obtained by $\mathit{ah}_2 = \mathit{frg}(\mathit{ah}_1,S)$.

    Let $y'$ be the operation context of $\mathit{ah}_1$ and $o$, and let $y''$ be the operation context of $\mathit{ah}_2$ and $o$. By transition $q'_1 {\xrightarrow{\alpha}'}_r q'_2$ we ensure that $y'' \in \mathit{Spec}(\ell)$. By the property of collection specification, we can see that $y' \in \mathit{Spec}(\ell)$. This implies that $(O_1,\mathit{ro}_1,\mathit{del}_1,\mathit{arb}_1) {\xrightarrow{(m,a,b,r,\mathit{arb}_1)}}_r q_2 = (O_1,\mathit{ro}_1,\mathit{del}_1,\mathit{arb}_1)$ and it is obvious that $q'_2 = \mathit{frg}(q_2,S)$.

\item[-] $\alpha' = (\ell,r,\_)$ is of a update method: Let annotated history $\mathit{ah}_1 = (O_{\mathit{ah1}},\mathit{vis}_{\mathit{ah1}},\mathit{arb}_{\mathit{ah1}})$, where $O_{\mathit{ah1}} = O_1 \cup \{ o \}$, $o \notin O$, $\mathit{lab}(o)=\ell$, $\mathit{vis}_{\mathit{ah1}}$ is obtained from replica order $\mathit{ro}_1 \cup \{ (o',o) \vert o' = (\_,r,\_) \in O_1\}$ and delivery order $\mathit{del}_1$, and $\mathit{arb}_{\mathit{ah1}}$ is a arbitration order that is obtained from $\mathit{arb}_1$ by possibly inserting $o$ into someplace and make the projection of $\mathit{arb}_{\mathit{ah1}}$ into operations of $q'_2$ the same as the arbitration order of $q'_2$. It is easy to see that $S$ can be forgotten from the set of states of $\mathit{ah}_1$, and let annotated history $\mathit{ah}_2$ be obtained by $\mathit{ah}_2 = \mathit{frg}(\mathit{ah}_1,S)$.

    Let $y'$ be the operation context of $\mathit{ah}_1$ and $o$, and the arbitration order of $y'$ is the projection of $\mathit{arb}_{\mathit{ah1}}$ into operations of $y'$. Let $y''$ be the operation context of $\mathit{ah}_2$ and $o$, and the arbitration order of $y''$ is the projection of the arbitration order of $y'$ into operations of $y''$. By transition $q'_1 {\xrightarrow{\alpha}'}_r q'_2$ we ensure that $y'' \in \mathit{Spec}(\ell)$. By the property of collection specification, we can see that $y' \in \mathit{Spec}(\ell)$. This implies that $(O_1,\mathit{ro}_1,\mathit{del}_1,\mathit{arb}_1) {\xrightarrow{(m,a,b,r,\mathit{arb}_{\mathit{ah1}})}}_r q_2 =  (O_1 \cup \{ o \},\mathit{ro}_1 \oplus o ,\mathit{del}_1 \oplus o,\mathit{arb}_{\mathit{ah1}})$. It is obvious that $q'_2 = \mathit{frg}(q_2,S)$.
\end{itemize}
This completes the proof of this lemma. $\qed$
\end {proof}



With Lemma \ref{lemma:RImpSpec is simulated by SRimpSpec} and Lemma \ref{lemma:SRImpSpec is simulated by RimpSpec}, we could prove Theorem \ref{theorem:SRIMPSpec and RIMPSpec have same history}.



{\noindent \bf Theorem \ref{theorem:SRIMPSpec and RIMPSpec have same history}}: $\mathit{his}(\mathit{RImp}(\mathit{Spec})) = \mathit{his}(\mathit{SRImp}(\mathit{Spec}))$.

\begin {proof}

Let $\rightarrow_r$ and $\rightarrow_s$ be the transition relation of $\mathit{RImp}(\mathit{Spec})$ and $\mathit{SRImp}(\mathit{Spec})$, respectively.

Let us prove the $\subseteq$ direction. Given a execution $e_r = q_0 {\xrightarrow{\alpha_1}}_r q_1 \ldots$ of $\mathit{RImp}(\mathit{Spec})$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $q_0 {\xrightarrow{\alpha_1}}_r q_1$: By definition of $\rightarrow_s$, we know that there exists $S_1$ and state $q'_1$, such that $q'_1 = \mathit{frg}^*(q_1)$, $q'_1 = \mathit{frg}(q_1,S_1)$ and $q_0 {\xrightarrow{\alpha_1}}_s q'_1$.

\item[-] $q_1 {\xrightarrow{\alpha_2}}_r q_2$: Since $q'_1 = \mathit{frg}(q_1,S_1)$, by Lemma \ref{lemma:RImpSpec is simulated by SRimpSpec} we can see that $\exists \alpha'_2, q'_2$, such that $q'_1 {\xrightarrow{\alpha'_2}}_r q'_2$ and $q'_2 = \mathit{frg}(q_2,S_1)$.

By definition of $\rightarrow_s$, we know that there exists $S_1$ and state $q''_2$, such that $q''_2 = \mathit{frg}^*(q'_2)$, $q''_2 = \mathit{frg}(q'_2,S_2)$ and $q'_1 {\xrightarrow{\alpha'_2}}_s q''_2$. By the property of collection specification, we have $q''_2 = \mathit{frg}(q_2,S_1 \cup S_2)$.

\item[-] For $u \geq 2$ and $q_u {\xrightarrow{\alpha_{u+1}}}_r q_{u+1}$: Assume that $q''_u = \mathit{frg}(q_u,S'_u)$.

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $\alpha_{u+1} = \mathit{addDel}(o,r)$ and $o$ is in the set of operations that can be forgotten from $q_u$: Let $q''_{u+1} = q''_u$. It is easy to see that $q''_{u+1} = \mathit{frg}(q_u,S'_u)$.

    \item[-] Otherwise: Since $q''_u = \mathit{frg}(q_u,S'_u)$, by Lemma \ref{lemma:RImpSpec is simulated by SRimpSpec} we can see that $\exists \alpha'_{u+1}, q'_{u+1}$, such that $q''_u {\xrightarrow{\alpha'_{u+1}}}_r q'_{u+1}$ and $q'_{u+1} = \mathit{frg}(q_{u+1},S'_u)$.

    By definition of $\rightarrow_s$, we know that there exists $S_{u+1}$ and state $q''_{u+1}$, such that $q''_{u+1} = \mathit{frg}^*(q'_{u+1})$, $q''_{u+1} = \mathit{frg}(q'_{u+1},S_{u+1})$ and $q''_u {\xrightarrow{\alpha'_{u+1}}}_s q''_{u+1}$. By the property of collection specification, we have $q''_{u+1} = \mathit{frg}(q_{u+1},S'_u \cup S_{u+1})$.
    \end{itemize}
\end{itemize}

With this method, we build a execution $e_s$ of $\mathit{SRImp}(\mathit{Spec})$, and by Lemma \ref{lemma:RImpSpec is simulated by SRimpSpec} it is easy to see that the history of $e_r$ is the same as that of $e_s$.

Let us prove the $\supseteq$ direction. Given a execution $e'_s = q_0 {\xrightarrow{\beta_1}}_s q_1 \ldots$ of $\mathit{SRImp}(\mathit{Spec})$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $q_0 {\xrightarrow{\alpha_1}}_s q_1$: By definition of $\rightarrow_s$, we know that there exists $S_1$ and state $q'_1$, such that $q_1 = \mathit{frg}^*(q'_1)$, $q_1 = \mathit{frg}(q'_1,S_1)$ and $q_0 {\xrightarrow{\alpha_1}}_r q'_1$.

\item[-] $q_1 {\xrightarrow{\alpha_2}}_s q_2$: By definition of $\rightarrow_s$, we know that there exists $S_2$ and state $q'_2$, such that $q_2 = \mathit{frg}^*(q'_2)$, $q_2 = \mathit{frg}(q'_2,S_2)$ and $q_1 {\xrightarrow{\alpha_2}}_r q'_2$.

    Since $q_1 {\xrightarrow{\alpha_2}}_r q'_2$ and $q_1 = \mathit{frg}(q'_1,S_1)$, by Lemma \ref{lemma:SRImpSpec is simulated by RimpSpec} we can see that $\exists \alpha'_2, q''_2$, such that $q'_1 {\xrightarrow{\alpha'_2}}_r q''_2$ and $q'_2 = \mathit{frg}(q''_2,S_1)$. By the property of collection specification, we have $q_2 = \mathit{frg}(q''_2,S_1 \cup S_2)$.

\item[-] $q_u {\xrightarrow{\alpha_{u+1}}}_s q_{u+1}$ for $u \geq 2$: By definition of $\rightarrow_s$, we know that there exists $S_{u+1}$ and state $q'_{u+1}$, such that $q_{u+1} = \mathit{frg}^*(q'_{u+1})$, $q_{u+1} = \mathit{frg}(q'_{u+1},S_{u+1})$ and $q_u {\xrightarrow{\alpha_{u+1}}}_r q'_{u+1}$.

    We already know that $q_u = \mathit{frg}(q''_u,S_1 \cup \ldots \cup S_u)$. Since $q_u {\xrightarrow{\alpha_{u+1}}}_r q'_{u+1}$, by Lemma \ref{lemma:SRImpSpec is simulated by RimpSpec} we can see that $\exists \alpha'_{u+1}, q''_{u+1}$, such that $q'_u {\xrightarrow{\alpha'_{u+1}}}_r q''_{u+1}$ and $q'_{u+1} = \mathit{frg}(q''_{u+1},S_1 \cup \ldots \cup S_u)$. By the property of collection specification, we have $q_{u+1} = \mathit{frg}(q''_{u+1},S_1 \cup \ldots \cup S_{u+1})$.
\end{itemize}

With this method, we build a execution $e'_r$ of $\mathit{RImp}(\mathit{Spec})$, and by Lemma \ref{lemma:SRImpSpec is simulated by RimpSpec} it is easy to see that the history of $e'_s$ is the same as that of $e'_r$. This completes the proof of this lemma. $\qed$
\end {proof}


Given a state $q = (O,\mathit{ro},\mathit{del},\mathit{arb})$ of $\mathit{RImp}( S_{\mathit{ORS}} )$, let a inductive variants $\mathit{Ind}(S_{\mathit{ORS}})(q)$ be defined as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{Ind}(S_{\mathit{ORS}})(q)$: For each $o_r \in O$ with $\mathit{lab}(o) = \mathit{rem}(a)$, there exists $o_a \in O$ with $\mathit{lab}(o_a) = \mathit{add}(a)$, such that $o_r \in \mathit{FstRem}(O,\mathit{vis},o_a)$.
\end{itemize}

From now on, for $\mathit{RImp}( S_{\mathit{ORS}} )$, we only consider its states that satisfy $\mathit{Ind}(S_{\mathit{ORS}})(q)$. With this assumption, we prove Lemma \ref{lemma:OR-set is collection specification} as follows.

{\noindent \bf Lemma \ref{lemma:OR-set is collection specification}}: OR-set specification $S_{\mathit{ORS}}$ is a collection specification.

\begin {proof}

%Let $\rightarrow$ be the transition relation of $RImp(S_{\mathit{ORS}})$. Given $(q_k,q'_k) \in R_{S}$, let $f$ be short for $map_{(q_k,q'_k,S)}$, assume $q_k = (O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k)$ and $q'_k = (O'_k,\mathit{ro}'_k,\mathit{del}'_k,\mathit{arb}'_k)$.

Let us prove the requirements of collection specification one by one:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Requirement $1$: Given an annotated history $x = (O,\mathit{vis},\emptyset)$, if $S$ can be forgotten from $O$, then for each extension $x' = (O',\mathit{vis}',\emptyset)$ of $x$, $S$ can be forgotten from $O'$.

    Proof of requirement $1$: This holds since $\mathit{vis}' \uparrow_{O} = \mathit{vis}$. $\newline$
\item[-] Requirement $2$: For each annotated history $x = (O,\mathit{vis},\emptyset)$ and $S \subseteq O$, where $S$ can be forgotten from $O$. For each operation label $\ell$ and extension $x' = (O',\mathit{vis}',\emptyset)$ of $x$, let $y'$ be the operation context of $x'$ and a maximal $o \in O$, and let $y''$ be the operation context of $frg(x',S) = (O'',\mathit{vis}'',\emptyset)$ and $o$, then $y' \in Spec(\ell)$, if and only if $y'' \in Spec(\ell)$.

    Proof of requirement $2$: Let us prove by considering all kinds of $\ell$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] $\ell = \mathit{add}(a)$: Trivially holds.

    \item[-] $\ell = \mathit{lookup}(a) \Rightarrow \mathit{true}$: Since $\mathit{vis}' \uparrow_{O} = \mathit{vis}'' \uparrow_{O} = \mathit{vis}$, if $o\in O$, then this holds obviously.

        Let us consider the case where $o \notin O$. If $S$ does not contain $\mathit{add}(a)$, then this obviously holds since $\mathit{vis}' \uparrow_{O''} = \mathit{vis}''$.

        Else, if $S$ contains $\mathit{add}(a)$. If $o_{\mathit{aa}} \in S$ with operation label $\mathit{add}(a)$ is in $y'$ or $y''$, then by construction of $S$ and by the construction of operation text of OR-set, there exists a $o_{\mathit{rr}} \in S$ with operation label $\mathit{rem}(a)$, such that $o_{\mathit{rr}}$ is also in $y'$ or $y''$, and $y'$ or $y''$ could know $o_{\mathit{rr}} \in \mathit{FstRem}( o_{\mathit{aa}} )$. This implies that there exists a maximal $\mathit{add}(a)$ operation $o_1 \notin S$ in $y'$ or $y''$. Since the order of $y'$ and $y''$ preserves order of $\mathit{FstRem}$, we can see that $o_1$ is maximal in both $y'$ and $y''$. Therefore, $y',y'' \in \mathit{Spec}(\ell)$.

    \item[-] $\ell = \mathit{lookup}(a) \Rightarrow \mathit{false}$: Since $\mathit{vis}' \uparrow_{O} = \mathit{vis}'' \uparrow_{O} = \mathit{vis}$, if $o\in O$, then this holds obviously. Else, since the order of $y'$ and $y''$ preserves order of $\mathit{FstRem}$, it is easy to see that $y',y'' \in \mathit{Spec}(\ell)$.

    \item[-] $\ell = \mathit{rem}(a)$: Similar as the case of $\ell = \mathit{lookup}(a) \Rightarrow \mathit{true}$.

    \item[-] $\ell = \mathit{elements}()\Rightarrow S$: This holds since the cases of $\ell = \mathit{lookup}(a) \Rightarrow \mathit{true}$ and $\ell = \mathit{lookup}(a) \Rightarrow \mathit{false}$ hold.
    \end{itemize}
    $\newline$

\item[-] Requirement $3$: If $\mathit{frg}(q,S) = q' \wedge \mathit{frg}(q',S') = q''$, then $\mathit{frg}(q,S \cup S') =q''$.

    Proof of requirement $3$: Assume $q = (O,\mathit{ro},\mathit{del},\mathit{arb})$ and $q' = (O',\mathit{ro}',\mathit{del}',\mathit{arb}')$. For each $o_a = (\mathit{add}(a),\_,\_) \in S \cup S'$, we can see that it has been visible to each replica in $\mathit{vis}$ and $\mathit{vis}'$. For each $o_r = (\mathit{rem}(a),\_,\_) \in S \cup S'$, if $o_r \in S$, then $\{ o_a \vert o_r \in \mathit{FstRem}(O,\mathit{vis},o_a) \} \subseteq S \subset S \cup S'$. Else, if $o_r \notin S$, then $\{ o_a \vert o_r \in \mathit{FstRem}(O',\mathit{vis}',o_a) \} \subseteq S'$, and we can see that $\{ o_a \vert o_r \in \mathit{FstRem}(O,\mathit{vis},o_a) \} \subseteq S' \cup S$, since $\mathit{vis} \uparrow_{O'} = \mathit{vis}'$. $\newline$

\item[-] Requirement $4$: Given an annotated history $x = (O,\_,\_)$ and its extension $x' = (O',\_,\_)$. Assume $S$ can be removed from the set of operations of $x$, and $x''$ is obtained from $x'$ by adding or removing pairs in $\{ (o_1,o_2) \vert o_1 \in S, o_2 \in O' \setminus O \}$. Then the set of operations that can be forgotten of $x'$ is the same as that of $x''$.

    Proof of requirement $4$: For the case when $x''$ is obtained from $x'$ by adding one such pair $(o_1,o_2)$: The $\mathit{FstRem}$ relation for pairs of operations where both are in $O$ or in $O' \setminus O$ remains the same. By definition there is no $\mathit{FstRem}$ relation for pairs of $\mathit{add}$ in $O' \setminus O$ and $\mathit{rem}$ in $O$. By the definition of $\mathit{FstRem}$, it is easy to see that the pair of $\mathit{add}$ in $S$ and $\mathit{rem}$ in $O' \setminus O$ can not be in $\mathit{FstRem}$. Therefore, the $\mathit{FstRem}$ in $x'$ and $x''$ is the same. The case when $x''$ is obtained from $x'$ by removing one such pair $(o_1,o_2)$ can be similarly dealt with.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}

%Given a state $(O,\mathit{ro},\mathit{del},\mathit{arb})$, its annotated history is a tuple $(o,\mathit{vis} \uparrow_{O},\mathit{arb})$.
Given a state $q = (O,\mathit{ro},\mathit{del},\mathit{arb})$ of $\mathit{RImp}( S_{\mathit{list}} )$, let a inductive variants $\mathit{Ind}(S_{\mathit{list}})(q)$ be defined as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{Ind}(S_{\mathit{list}})(q)$: For each $a$, there is at most one $\mathit{add}(a) \in O$, and for each replica $r$, there is at most one $o = \mathit{rem}(a) \in \mathit{visTo}(O,\mathit{vis},r)$.
\end{itemize}

From now on, for $\mathit{RImp}( S_{\mathit{list}} )$, we only consider its states that satisfy $\mathit{Ind}(S_{\mathit{list}})$. We slightly modify the second requirement of collection into the following:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] For each annotated history $x = (O,\mathit{vis},\mathit{arb})$ and $S \subseteq O$, where $S$ can be forgotten from $O$. For each operation label $\ell$ and extension $x' = (O',\mathit{vis}',\mathit{arb}')$ of $x$, let $y'$ be the operation context of $x'$ and a maximal $o \in O$, and let $y''$ be the operation context of $frg(x',S) = (O'',\mathit{vis}'',\mathit{arb}'')$ and $o$. Here we only permit $o$ to have argument $\mathit{pos}$ (if it is $\mathit{add}$) while such argument for other operations are ignored by definition. Then $y' \in Spec(\ell)$, if and only if $y'' \in Spec(\ell)$.
\end{itemize}

With this modified collection, we can similarly define Lemma \ref{lemma:RImpSpec is simulated by SRimpSpec} and Lemma \ref{lemma:SRImpSpec is simulated by RimpSpec}.

Then, let us prove Lemma \ref{lemma:list is collection specification} as follows.

\begin{lemma}
\label{lemma:list is collection specification}
Distributed list specification $S_{\mathit{list}}$ is a collection specification.

\end{lemma}

%{\noindent \bf Lemma \ref{lemma:list is collection specification}}: Distributed list specification $S_{\mathit{list}}$ is a collection specification.

\begin {proof}

%Let $\rightarrow$ be the transition relation of $RImp(S_{\mathit{ORS}})$. Given $(q_k,q'_k) \in R_{S}$, let $f$ be short for $map_{(q_k,q'_k,S)}$, assume $q_k = (O_k,\mathit{ro}_k,\mathit{del}_k,\mathit{arb}_k)$ and $q'_k = (O'_k,\mathit{ro}'_k,\mathit{del}'_k,\mathit{arb}'_k)$.

Let us prove the requirements of collection specification one by one:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Requirement $1$: Given an annotated history $x = (O,\mathit{vis},\mathit{arb})$, if $S$ can be forgotten from $O$, then for each extension $x' = (O',\mathit{vis}',\mathit{arb}')$ of $x$, $S$ can be forgotten from $O'$.

    Proof of requirement $1$: This holds since $\mathit{vis}' \uparrow_{O} = \mathit{vis}$. $\newline$
\item[-] Requirement $2$: For each annotated history $x = (O,\mathit{vis},\mathit{arb})$ and $S \subseteq O$, where $S$ can be forgotten from $O$. For each operation label $\ell$ and extension $x' = (O',\mathit{vis}',\mathit{arb}')$ of $x$, let $y'$ be the operation context of $x'$ and a maximal $o \in O$, and let $y''$ be the operation context of $frg(x',S) = (O'',\mathit{vis}'',\mathit{arb}'')$ and $o$. Here we only permit $o$ to have argument $\mathit{pos}$ (if it is $\mathit{add}$) while such argument for other operations are ignored by definition. Then $y' \in Spec(\ell)$, if and only if $y'' \in Spec(\ell)$.

    Proof of requirement $2$: The only difference in operation context of $o$ is $S$. Since the values putted in $S$ is seen by each replica and also its remove is seen by each replica, they does take effect in both $y'$ and $y''$. $\newline$

\item[-] Requirement $3$: If $\mathit{frg}(q,S) = q' \wedge \mathit{frg}(q',S') = q''$, then $\mathit{frg}(q,S \cup S') =q''$.

    Proof of requirement $3$: It is easy to see that $S \cap S' = \emptyset$. this holds since the identifiers in $S$ and $S'$ are different.

\item[-] Requirement $4$: Given an annotated history $x = (O,\_,\_)$ and its extension $x' = (O',\_,\_)$. Assume $S$ can be removed from the set of operations of $x$, and $x''$ is obtained from $x'$ by adding or removing pairs in $\{ (o_1,o_2) \vert o_1 \in S, o_2 \in O' \setminus O \}$. Then the set of operations that can be forgotten of $x'$ is the same as that of $x''$.

    Proof of requirement $4$: This holds since each value is putted only once globally, and removed only once for each replica.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}










\section{Definitions and Proofs of Section \ref{sec:implementation}}
\label{sec:appendix definitions and proofs of section implementation}

The semantics of $\mathit{imp}$ with causal delivery is given as an LTS $[|\mathit{Imp}|]_{\mathit{cd}} = (Q_{\mathit{cd}},\Sigma,\rightarrow_{\mathit{cd}},q_0)$, where

\begin {itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each state of $Q_{\mathit{cd}}$ is for the from $(\mathit{data},\mathit{msgs},\mathit{msghb})$, where $\mathit{data}$ and $\mathit{msgs}$ is the same as that in $[|\mathit{Imp}|])$, and $\mathit{msghb} \subseteq (\mathit{msgs} \times \mathit{msgs}) \cup (\mathit{msgs} \times \mathbb{R})$ is a transitive, acyclic and irreflexive relation. $\mathit{msghb}$ is used to record the happen-before relation between ``operations'' of messages. %$(m_1,m_2) \in <$ represents that the $op(m_1)$ happen before $op(m_2)$, while $(m,r) \in <$ represents that $op(m)$ is visible to replica $r$ and does not happen before any operation of replica $r$ that we could know.
    $(\mathit{msg}_1,\mathit{msg}_2) \in \mathit{msghb}$, if the operation generating $\mathit{msg}_1$ happens before the operation generating $\mathit{msg}_2$, and $\mathit{msg}_1$ and $\mathit{msg}_2$ have same destination replica. $(\mathit{msg},r) \in \mathit{hb}$ represents that the operation generating $\mathit{msg}$ is visible to replica $r$ and does not happen before any operation of replica $r$ currently.

\item[-] $\rightarrow_{\mathit{cd}}$ is the transition relation:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] When $m$ is a query method:

    $\begin{array}{l c} \bigfrac{ (\mathit{data}[r],m,a,r) \rightarrow_o (d,b,\emptyset),f_{\mathit{arb}}(\mathit{data}[r:d],\mathit{msgs}) = \mathit{arb}} {(\mathit{data},\mathit{msgs},\mathit{msghb}) {\xrightarrow{(m,a,b,r,\mathit{arb})}} (\mathit{data}[r:d],\mathit{msgs},\mathit{msghb})} \end{array}$

    \item[-] When $m$ is a update method:

    $\begin{array}{l c} \bigfrac{ (\mathit{data}[r],m,a,r) \rightarrow_o (b,d,\mathit{msgs}'), f_{\mathit{arb}}(\mathit{data}[r:d], \mathit{msgs} \cup \mathit{msgs}') = \mathit{arb} } {(\mathit{data},\mathit{msgs},\mathit{msghb}) {\xrightarrow{(m,a,b,r,\mathit{arb})}} (\mathit{data}[r:d],\mathit{msgs} \cup \mathit{msgs}',\mathit{msghb} \otimes \mathit{msgs}')} \end{array}$

    Assume message of $\mathit{msgs}'$ is in the form $(\mathit{da},\_,\_)$. Let $\mathit{msgs}(r)$ be the set of messages of $\mathit{msgs}$ with destination replica identifier $r$. $\mathit{msghb} \otimes \mathit{msgs}'$ returns a new message happen-before relation as follows:

        \begin{itemize}
        \setlength{\itemsep}{0.5pt}
        \item[-] For each replica $r' \in \mathbb{R}$, in $\mathit{msgs}(r')$, if $(\mathit{msg}_1,r) \in \mathit{hb}$, then remove $(\mathit{msg}_1,r)$ from $\mathit{msghb}$ and add $(m_1,(\mathit{da},r,r'))$ into $\mathit{hb}$,

        \item[-] For each replica $r' \in \mathbb{R}$, if $\mathit{msg}_1$ is maximal among $\{ (\_,r,r') \}$ w.r.t $\mathit{msghb}$, then add $(\mathit{msg}_1,(\mathit{da},r,r'))$ into $\mathit{hb}$.

        \item[-] Make $\mathit{msghb}$ a transitive closure.
        \end{itemize}

    \item[-]

        $\begin{array}{l c} \bigfrac{ (\mathit{data}[r],r,m) \rightarrow_m d, m \ is \ minimal \ w.r.t \ \mathit{msghb} \ among \ \mathit{msgs}(r) } {(\mathit{data},\mathit{msgs},\mathit{msghb}) {\xrightarrow{\mathit{apply}(m)}} (\mathit{data}[r:d],\mathit{msgs} \setminus \{ m \}, \mathit{msghb} \otimes m )} \end{array}$

         Assume $m = (\mathit{da},r_1,r)$. $\mathit{msghb} \otimes m$ returns a new happen-before relation as follows:

        \begin{itemize}
        \setlength{\itemsep}{0.5pt}
        \item[-] Remove $m$ from pairs in $\mathit{msghb}$ while keeps the relation for other elements unchanged.

        \item[-] Then, for each $r' \neq r$, if $(\mathit{da},r_1,r') \in \mathit{msgs}(r')$, then add $((\mathit{da},r_m,r'),r)$ into $\mathit{msghb}$.

        \item[-] Make $\mathit{msghb}$ a transitive closure.
        \end{itemize}
    \end{itemize}
%\item[-] $q_0$ is the initial state, which maps each replica identifier into $(InitD,\emptyset,\emptyset)$.
\end{itemize}

The following lemma states that, $[|\mathit{Imp}|]_{\mathit{cd}}$ contains the set of causal delivery executions of $[|\mathit{Imp}|]$.

\begin{lemma}
\label{lemma:semantics of imp cd contains the set of causal delivery executions of semantics of imp}
$\mathit{trace}( [|\mathit{Imp}|]_{\mathit{cd}} ) = \{ t \vert t \in \mathit{trace}( [|\mathit{Imp}|] ) \wedge t$ satisfies causal delivery $\}$.
\end{lemma}

\begin {proof}

Let $q_0 {\xrightarrow{\alpha_1}} q_1 \ldots$ be the execution of $t = \alpha_1 \cdot \ldots \in \mathit{trace}( [|\mathit{Imp}|]_{\mathit{cd}} )$. Let $\alpha[1,u] = \alpha_1 \cdot \ldots \cdot \alpha_u$. We need to prove the following properties: On each state $q_i=(\mathit{data}_i,\mathit{msgs}_i,<_i)$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{Prop}_1$: $\mathit{msgs}_i = \{ (\mathit{da},r,r') \vert$ the operation generating this message is launched by replica $r$ and its message has not been applied to replica $r'$ in $t[1,i]\}$.

\item[-] $\mathit{Prop}_2$: $\mathit{msg}_1 <_i \mathit{msg}_2$, iff $\mathit{msg}_1$ and $\mathit{msg}_2$ have same destination replica, and the operation generating $\mathit{msg}_1$ happens before the operation generating $\mathit{msg}_2$ in $t[1,i]$.

\item[-] $\mathit{Prop}_3$: $\mathit{msg} <_i r$, iff the destination replica of $\mathit{msg}$ is not $r$, and the operation generating $\mathit{msg}$ is visible to replica $r$ in $t[1,i]$, and does not happen before ``any operation that launched by replica $r$'' in $t[1,i]$.
\end{itemize}

By definition it is easy to see that each trace of $\mathit{trace}( [|\mathit{Imp}|]_{\mathit{cd}} )$ is also a trace of $\mathit{trace}( [|\mathit{Imp}|] )$. Once we prove that $\mathit{Prop}_1$, $\mathit{Prop}_2$ and $\mathit{Prop}_3$ holds for each $q_i$, let us prove this lemma by contradiction: Assume that update operations $o_1 <_{hb} o_2$, messages of $o_1$ are $\{ (d_1,r_1,\_) \}$, messages of $o_2$ are \{ $(d_2,r_2,\_) \}$, $\alpha_i = apply((d_2,r_2,r'))$, and no $apply((d_1,r_1,r'))$ happens earlier than $\alpha_i$ in $t$. Then in $q_i=(\mathit{data}_i,\mathit{msgs}_i,<_i)$, since $o_1 <_{hb} o_2$ and transition rules of $\mathit{trace}( _{\mathit{cd}} )$, we could not launch $apply((d_2,r_2,r'),)$ transition, which is the contradiction.


Let us begin to prove that each state $q_i=(\mathit{data}_i,\mathit{msgs}_i,<_i)$ satisfies properties $\mathit{Prop}_1$, $\mathit{Prop}_2$ and $\mathit{Prop}_3$. We prove this by induction on $t$.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] It is obvious that $q_0$ satisfies properties $\mathit{Prop}_1$, $\mathit{Prop}_2$ and $\mathit{Prop}_3$.

\item[-] Since $\alpha_1$ must be either a query transition or an update transition, it is easy to see that $<_1 = \emptyset$ and $q_1$ satisfies properties $\mathit{Prop}_1$, $\mathit{Prop}_2$ and $\mathit{Prop}_3$.

\item[-] Assume that $q_k=(\mathit{data}_k,\mathit{msgs}_k,<_k)$ satisfies properties $\mathit{Prop}_1$, $\mathit{Prop}_2$ and $\mathit{Prop}_3$. let us consider $q_{k+1}= (\mathit{data}_{k+1},\mathit{msgs}_{k+1},<_{k+1})$,

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $q_{k+1}$ is obtained from $q_k$ by a query transition, then this holds obviously.

    \item[-] Else, if $q_{k+1}$ is obtained from $q_k$ by a update transition. Then we can see that $(\mathit{data}_k,\mathit{msgs}_k,<_k) {\xrightarrow{(m,a,b,r)}} (\mathit{data}_{k+1},\mathit{msgs}_{k+1}= \mathit{msgs} \cup \{ (\mathit{da},r,r') \vert  r' \in \mathbb{R} \wedge r \neq r' \},<_{k+1} = <_k \otimes \{ (\mathit{da},r,r') \vert  r' \in \mathbb{R} \wedge r \neq r' \}$.

        Since we add messages $\{ (\mathit{da},r,r') \vert  r' \in \mathbb{R} \wedge r \neq r' \}$ into $\mathit{msgs}_i$, we can see that $\mathit{Prop}_1$ holds.

        To satisfy $\mathit{Prop}_2$ and $\mathit{Prop}_3$, we need to make newly add messages maximal w.r.t $<$ and still keep transitivity, which is done by $<_k \otimes \{ (\mathit{da},r,r') \vert  r' \in \mathbb{R} \wedge r \neq r' \}$.

    \item[-] Else, $q_{k+1}$ is obtained from $q_k$ by a applying transition. Then we can see that $(\mathit{data}_k,msgs_k,<_k) {\xrightarrow{apply(\mathit{msg}=(\mathit{da},r_1,r))}} (\mathit{data}_{k+1},\mathit{msgs}_{k+1} = \mathit{msgs}_k \setminus \{ \mathit{msg} \}, <_{k+1} = <_k \otimes \mathit{msg} )$, where $\mathit{msg}$ is minimal w.r.t $<_k$ among messages in $\mathit{msgs}_i(r)$.

        Since we use one message $\mathit{msg}$ in this process and remove it from $\mathit{msgs}_i$, we can see that $\mathit{Prop}_1$ holds.

        Applying message will introduce new visibility relation. To satisfy $\mathit{Prop}_2$ and $\mathit{Prop}_3$, we need to first forget $\mathit{msg}$, record the newly introduced visibility relation, and still keep transitivity. This is done by $<_k \otimes \mathit{msg}$.
    \end{itemize}
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}
















\section{Definitions and Proofs of Section \ref{sec:simulation and refinement}}
\label{sec:appendix definitions and proofs of section simulation and refinement}




\subsection{Proof of Theorem \ref{theorem:equivalence of our simulation and refinement}}
\label{subsec:proof of theorem equivalence of our simulation and refinement}


{\noindent \bf Theorem \ref{theorem:equivalence of our simulation and refinement}}: Given LTS $A$ and deterministic $B$, and functions $f_s,f_t$, such that $P_{(f_s,f_t)}$ holds. Then, B $f_t$-refines $A$, if and only if there exists a $f_s$-simulation relation between $A$ and $B$.

\begin {proof}
Assume $A = (Q_A,\Sigma_A,\rightarrow_a,q_{0A})$ and $B = (Q_B,\Sigma_B,\rightarrow_b,q_{0B})$.

For the $\mathit{if}$ direction. Assume $R$ is a $f_s$-simulation relation between $A$ and $B$. Given $q_{1A},\ldots,q_{kA} \in Q_A$, $q_{1B},\ldots,q_{kB}$, $\alpha_1,\ldots,\alpha_k$, such that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\forall 0 \leq i < k$, $q_{iA} {\xrightarrow{\alpha_{i+1}}}_a q_{i+1A}$,

\item[-] $\forall 0 \leq i \leq k$, $(q_{iA},q_{iB}) \in R$, and

\item[-] $\forall 0 \leq i < k$, $q_{iB} {\xrightarrow{f_s(q_{iA},q_{iB},\alpha_{i+1})}}_b q_{i+1B}$.
\end{itemize}

We can see that, given execution $t_A = \alpha_1 \cdot \ldots \cdot \alpha_k$ of $A$, by $f_s$-simulation, we have execution $t_b = f_s(q_{0A},q_{0B},\alpha_1) \cdot \ldots \cdot f_s(q_{k-1A},q_{k-1B},\alpha_k)$ of $B$.

Since $P_{(f_s,f_t)}$ holds, we can see that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $f_t(\alpha_1) = f_s(q_{0A},q_{0B},\alpha_1)$.

\item[-] $f_t(\alpha_1 \cdot \alpha_2) = f_s(q_{1A},q'_{1B},\alpha_2)$. Here $q'_{1B}$ is obtained from $q_{B0}$ by doing $\alpha_1$ transitions. Since $B$ is deterministic, it is easy to see that $q'_{1B} = q_{1B}$, and $f_t(\alpha_1 \cdot \alpha_2) = f_s(q_{1A},q_{1B},\alpha_2)$.

$\ldots$

\item[-] $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k) = f_s(q_{k-1A},q'_{k-1B},\alpha_k)$. Here $q'_{k-1B}$ is obtained from $q_{B0}$ by doing $\alpha_1 \cdot \ldots \cdot \alpha_{k-1}$ transitions. Since $B$ is deterministic, it is easy to see that $q'_{k-1B} = q_{k-1B}$, and $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k) = f_s(q_{k-1A},q_{k-1B},\alpha_k)$.
\end{itemize}

We can see that $t_B = f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)$. Therefore, by definition of $f_t$-refinement, we can see that B $f_t$-refines $A$.


For the $\mathit{only if}$ direction. Assume $B$ $f_t$-refines $A$. Let a relation $R_t$ be defined as follows: Given $q_A \in Q_A$ and $q_B \in Q_B$, $(q_A,q_B) \in R_t$, if $\exists \alpha_1, \ldots, \alpha_k \in \Sigma_A$, $\exists q_{1A},\ldots,q_{k-1A} \in Q_A$, and $\exists q_{1B},\ldots,q_{k-1B} \in Q_B$, such that $q_{0A} {\xrightarrow{\alpha_1}}_a q_{1A} \ldots {\xrightarrow{\alpha_{k-1}}}_a q_{k-1A} {\xrightarrow{\alpha_k}}_a q_A$, and $q_{0B} {\xrightarrow{f_t(\alpha_1)}}_b q_{1B} \ldots$ ${\xrightarrow{f_t(\alpha_1 \cdot \cdot \ldots \cdot \alpha_{k-1})}}_b q_{k-1B} {\xrightarrow{f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)}}_b q_B$.

Let us now prove that $R_t$ is a $f_s$-simulation relation. Assume that $q_A {\xrightarrow{\alpha}}_a q'_A$. Then we can see that $q_{0A} {\xrightarrow{\alpha_1}}_a q_{1A} \ldots {\xrightarrow{\alpha_{k-1}}}_a q_{k-1A} {\xrightarrow{\alpha_k}}_a q_A {\xrightarrow{\alpha}}_A q'_A$ and $\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha$ is an execution of $A$.

By assumption, $B$ $f_t$-refines $A$. Therefore, $f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k) \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha)$ is an execution of $B$. Since $B$ is deterministic, we can see that $\exists q'_B$, such that $q_{0B} {\xrightarrow{f_t(\alpha_1)}}_b q_{1B} \ldots$ ${\xrightarrow{f_t(\alpha_1 \cdot \cdot \ldots \cdot \alpha_{k-1})}}_b q_{k-1B} {\xrightarrow{f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)}}_b q_B {\xrightarrow{f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha)}}_b q'_B$. By definition, we can see that $(q'_A,q'_B) \in R_t$.

Since $P_{(f_s,f_t)}$ holds, we have that $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha) = f_s(q_A,q''_B,\alpha)$, where $q''_B$ is obtained from $q_{0B}$ by doing $f_t(\alpha_1) \cdot \ldots \cdot f_t(\alpha_1 \cdot \ldots \cdot \alpha_k)$ transitions. Since $B$ is deterministic, we can see that $q''_B = q_B$ and $f_t(\alpha_1 \cdot \ldots \cdot \alpha_k \cdot \alpha) = f_s(q_A,q_B,\alpha)$. We can see that $q_B {\xrightarrow{f_s(q_A,q_B,\alpha)}}_b q'_B$. Therefore, $R_t$ is a $f_s$-simulation relation. \qed
\end {proof}






\subsection{Example of OR-Set Algorithm of \cite{Shapiro:2011}}
\label{subsec:example of or-set algorithm that assumes causal delivery}


Given a state $q_{\mathit{imp}} = (\mathit{data},\mathit{msgs},\mathit{msghb})$ of implementation and a state $q_s = (O,\mathit{ro},\mathit{del},\mathit{arb})$ of specification, $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$ normally has the following conditions:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $C_{\mathit{ind}}$: For $q_s$: we use the inductive invariant $\mathit{Ind}(S_{\mathit{ORS}})(q)$ of Appendix \ref{sec:appendix definitions and proofs of section succinct reference implementations of collection data types}, and also require that the happen before relation to be transitive. For $q_{\mathit{imp}}$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] For each replica $r$: Let $\mathit{ID}_r = \{ k \vert \exists r' \in \mathbb{R}, (\_,(r,k)) \in \mathit{data}[r'].S \} \cup \{ k \vert (\_,(r,k),\_,\_) \in \mathit{msgs} \vee ( (\_,S',\_,\_) \in \mathit{msgs} \wedge (r,k) \in S' ) \}$. We require that each element of $\mathit{ID}_r$ is less than $\mathit{data}[r].\mathit{ctr}$.

    \item[-] For each replica $r$: $(a,S',r,\_) \in \mathit{msgs}$, then for each $\mathit{id} \in S'$, $(a,\mathit{id}) \notin \mathit{data}[r].S \wedge (a,\mathit{id},\_,r) \notin \mathit{msgs}$.
    \end{itemize}

\item[-] $C_{\mathit{rdt}}$: $(a,\mathit{id})$ is redundant, if $(a,\mathit{id},\_,\_) \notin \mathit{msgs}$, and for each replica $r$, $(a,\mathit{id}) \notin \mathit{data}[r].S$. $(a,S',r)$ is redundant, if for each $\mathit{id} \in S'$, $(a,\mathit{id})$ is redundant. Moreover, if $(a,S',r)$ is redundant, and there exists a message $(a,S',r,r') \in \mathit{msgs}$, then applying this message does not change local state.

\item[-] $C_{\mathit{map}}$: $f$ maps $(a,(r,\_))$ that are not redundant into $\mathit{add}(a)$ of replica $r$, and maps $(a,S',r)$ that are not redundant into $\mathit{rem}(a)$ of replica $r$.

\item[-] $C_{\mathit{msg}}$: For non redundant $(a,\mathit{id})$, $(a,\mathit{id},\_,r) \in \mathit{msgs}$, if and only if $f((a,\mathit{id})) \notin \mathit{visTo}(O,\mathit{vis},r)$. For non redundant $(a,S',r)$, $(a,S',r,r') \in \mathit{msgs}$, if and only if $f((a,S',r)) \notin \mathit{visTo}(O,\mathit{vis},r)$.

\item[-] $C_{\mathit{FM}}$: For each $\mathit{id} \in S'$, $f((a,S',r)) \in \mathit{FstRem}(O,\mathit{vis},f(a,\mathit{id}))$; while for each $\mathit{id} \notin S'$, $f((a,S',r)) \notin \mathit{FstRem}(O,\mathit{vis},f(a,\mathit{id}))$.

\item[-] $C_{\mathit{vis}}$: $(a,\mathit{id}) \in data[r].S$, if and only if $f((a,\mathit{id})) \in \mathit{visTo}(O,r,\mathit{vis})$, and for each $o_r \in \mathit{FstRem}(O,\mathit{vis},f((a,\mathit{id})))$, $o_r \notin \mathit{visTo}(O,r,\mathit{vis})$.

\item[-] $C_{\mathit{mhb}}$: Given $m_1,m_2 \in \mathit{msgs}$ and assume that their operations are $x_1$ and $x_2$, respectively. If $x_1$ and $x_2$ are both non-redundant, then, $(m_1,m_2) \in \mathit{msghb}$, if and only if $f(x_1)$ happens before $f(x_2)$, and $(m_1,r) \in \mathit{msghb}$, if and only if $(f(x_1),r) \in \mathit{del}$.
\end{itemize}


Let $\mathit{imp}_{\mathit{ORS}}^{cd}$ be the implementation of OR-Set Algorithm of \cite{Shapiro:2011} defined in Section \ref{sec:implementation}. The following lemma states that $R_{\mathit{ORS}}^{\mathit{cd}}$ is a $f_s$-simulation relation between $[|\mathit{imp}_{\mathit{ORS}}^{cd}|]_{\mathit{cd}}$ and $\mathit{SRImp}(S_{\mathit{ORS}})_{\mathit{cd}}$.


\begin{lemma}
\label{lemma:ROrscd is a fs simulation between orset causal delivery algorithm and orset specification}
$R_{\mathit{ORS}}^{\mathit{cd}}$ is a $f_s$-simulation relation between $[|\mathit{imp}_{\mathit{ORS}}^{cd}|]_{\mathit{cd}}$ and $\mathit{SRImp}(S_{\mathit{ORS}})_{\mathit{cd}}$.
\end{lemma}

\begin {proof}

Assume $q_{\mathit{imp}} = (\mathit{data},\mathit{msgs},\mathit{msghb})$, $q_s = (O,\mathit{ro},\mathit{del},\mathit{arb})$, $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$, and $q_{\mathit{imp}} \xrightarrow{\alpha}_i q'_{\mathit{imp}}$. We prove by consider all kinds of transitions:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{contain},a,\mathit{true},r,\emptyset )}_i q_{\mathit{imp}}$: There exists $\mathit{id}$, such that $(a,id) \in \mathit{data}[r].S$. Let $o \notin O$ be a $\mathit{contain}(a) \Rightarrow \mathit{true}$ operation of replica $r$. Let $c = (O_c,<_c,\emptyset) = f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o)$

If there exists a $\mathit{rem}(a)$ operation $o_r$, such that $(f((a,\mathit{id})),o_r) \in <_c$. By the definition of context of OR-set, we can see all the $<_c$ intermediate elements between $f((a,\mathit{id}))$ and $o_r$ are in $\mathit{visTo}(O,\mathit{vis},r)$. Let $o_1,\ldots,o_u$ be the $\mathit{add}(a)$ and $\mathit{rem}(a)$ operations among them.

If some $o_j$ is a $\mathit{rem}(a)$, then $o_j \in \mathit{FstRem}( f((a,\mathit{id})) )$, and this violates $C_{\mathit{vis}}$. If all $o_j$ are all $\mathit{add}(a)$, then $o_r \in \mathit{FstRem}( f((a,\mathit{id})) )$, and this violates $C_{\mathit{vis}}$. Therefore, such $o_r$ does not exists. Since every maximal element is $\mathit{add}(a)$, we can see that $q_s \xrightarrow{( \mathit{contain},a,\mathit{true},r,\emptyset )}_s q_s$, and recall that $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{contain},a,\mathit{false},r,\emptyset )}_i q_{\mathit{imp}}$: For each $\mathit{id}$, $(a,id) \notin \mathit{data}[r].S$. Let $o \notin O$ be a $\mathit{contain}(a) \Rightarrow \mathit{false}$ operation of replica $r$. Let $c = (O_c,<_c,\emptyset) = f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o)$

If there exists a $\mathit{add}(a)$ operation $o_a$, such that $o_a$ is maximal w.r.t $<_c$, then we know that $o_a \in \mathit{vis}(O,\mathit{vis},r)$, and for each $o_r \in \mathit{FstRem}(o_a)$. By $C_{\mathit{vis}}$ this means that there exists $\mathit{id}$, such that $f((a,\mathit{id})) = o_a$, and $(a,\mathit{id}) \in \mathit{data}[r].S$. This contradicts the assumption. Therefore, no such $o_a$ exists. Since every  maximal element is $\mathit{rem}(a)$, we can see that $q_s \xrightarrow{( \mathit{contain},a,\mathit{false},r,\emptyset )}_i q_s$, and recall that $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=(a,\mathit{id}),r,r' )}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ m \},\mathit{msghb}')$: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].S$ into $\mathit{data}[r'].S \cup \{ (a,\mathit{id}) \}$.

    By $C_{\mathit{msg}}$ we can see that $f((a,\mathit{id})) \notin \mathit{visTo}(O,\mathit{vis},r')$. Since $f$ is a one to one map, by $C_{\mathit{msg}}$ and $C_{\mathit{mhb}}$, we can do $q_s \xrightarrow{\mathit{addDel}( f(a,\mathit{id}),r' )}_s q'_s$. By $C_{\mathit{msg}}$ and $C_{\mathit{mhb}}$, the transitions do not make new element to become redundant in $q_{\mathit{imp}}$ and $q_s$. It is easy to see that all conditions still holds between $q'_{\mathit{imp}}$ and $q'_s$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=(a,S',r,r' ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ m \},\mathit{msghb}')$, and $(a,S,r)$ is not redundant: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].S$ into $\mathit{data}[r'].S \setminus \{ (a,\mathit{id}) \vert \mathit{id} \in S'\}$.

    Let $S'' = S''_a \cup S''_r$ be the set of elements that becomes redundant during this process, while $S''_a$ contains all $\mathit{add}$ in $S''$, and $S''_r$ contains all $\mathit{rem}$ in $S''$. Let $f'$ be obtained from $f$ by minus the domain by $S''$.

    By $C_{\mathit{hb}}$, we can see that $f((a,S',r))$ is the minimal w.r.t not in $\mathit{visTo}(O,\mathit{vis},r)$. Therefore, we can do $q_s \xrightarrow{\mathit{addDel}( f(a,S',r),r' )}_s q'_s$. By $C_{\mathit{FM}}$ and $C_{\mathit{msg}}$, we can see that $\{ o \vert \exists x \in S'', f(S'') = o \}$ is the set that becomes ``can be forgotten'' during this process in $q_s$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$. Then, we can see that $C_{\mathit{map}}$ and $C_{\mathit{rdt}}$ holds for $(q'_{\mathit{imp}},q'_s)$.

    Since forgetting does not change visibility for the remanning operations, it is easy to see that $C_{\mathit{FM}}$ and $C_{\mathit{vis}}$ hold for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that the change of message happen before of $q_{\mathit{imp}}$ corresponding to the change of happen before of $q_s$, and then $C_{\mathit{mhb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. It is obvious that $C_{\mathit{ind}}$ still holds for $(q'_{\mathit{imp}},q'_s)$. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=(a,S',r,r' ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ m \},\mathit{msghb}')$, and $(a,S',r)$ is redundant: By $C_{\mathit{rdt}}$, $\mathit{data}' = \mathit{data}$. Since the only change is applying a message, it is easy to see that $(q'_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{(\mathit{add},a,r,\emptyset)}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs}',\mathit{msghb}')$: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].S$ into $\mathit{data}[r'].S \cup \{ (a,\mathit{id} = (r,\mathit{data}[r].\mathit{ctr})) \}$, modifying $\mathit{data}[r].\mathit{ctr}$ into $\mathit{data}[r].\mathit{ctr}+1$, and $\mathit{msgs}' = \mathit{msgs} \cup \{ (a,\mathit{id},r,r') \vert r' \neq r \}$. It is obvious that we can do $q_s \xrightarrow{( \mathit{add},a,r,\emptyset )}_i q'_s$ and let $o$ be the newly generated operations in $q'_s$. It is obvious that $(a,\mathit{id})$ is not redundant in $q'_{\mathit{imp}}$. Let $f' = f \cup \{ ((a,id),,o) \}$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$.

    It is easy to see that no new operation becomes redundant in both implementation and specification. It is easy to see that the change of message happen before of $q_{\mathit{imp}}$ corresponding to the change of happen before of $q_s$, and then $C_{\mathit{mhb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Since there is no remove in $\mathit{FstRem}$ for $o$, and a new $\mathit{add}$ does not influence $\mathit{FstRem}$ for other operations, we have $C_{\mathit{FM}}$ holds for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that other condition also hold. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{rem},a,r,\emptyset ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs}',\mathit{msghb}')$: Let $S' = \{ \mathit{id} \vert (a,\mathit{id}) \in \mathit{data}[r].S \}$. $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r].S$ into $\mathit{data}[r].S \setminus \{ (a,\mathit{id}) \vert \mathit{id} \in S'\}$, $\mathit{msg}' = \mathit{msg} \cup \{ (a,S',r,r') \vert r' \neq r \}$.

    Let $S'' = S''_a \cup S''_r$ be the set of elements that becomes redundant during this process, while $S''_a$ contains all $\mathit{add}$ in $S''$, and $S''_r$ contains all $\mathit{rem}$ in $S''$. Let $f'$ be obtained from $f$ by minus the domain by $S''$.

    We already know that $S' \neq \emptyset$. By $C_{\mathit{vis}}$ and similar to the case of $\mathit{contains}(a) \Rightarrow \mathit{true}$, we can do $q_s \xrightarrow{( \mathit{rem},a,r,\emptyset )}_s q'_s$. By $C_{\mathit{FM}}$ and $C_{\mathit{msg}}$, we can see that $\{ o \vert \exists x \in S'', f(S'') = o \}$ is the set that becomes ``can be forgotten'' during this process in $q_s$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$.

    Since forgetting does not change visibility for the remanning operations, it is easy to see that $C_{\mathit{FM}}$, $C_{\mathit{vis}}$ and $C_{\mathit{msg}}$ hold for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that the change of message happen before of $q_{\mathit{imp}}$ corresponding to the change of happen before of $q_s$, and then $C_{\mathit{mhb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. By $C_{\mathit{vis}}$ and $C_{\mathit{msg}}$, we can see that $C_{\mathit{ind}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}








\subsection{Example of RGA Algorithm of \cite{Attiya:2016}}
\label{subsec:example of rga algorithm that assumes causal delivery}


Given a state $q_{\mathit{imp}} = (\mathit{data},\mathit{msgs},\mathit{msghb})$ of implementation and a state $q_s = (O,\mathit{ro},\mathit{del},\mathit{arb})$ of specification, $(q_{\mathit{imp}},q_s) \in R_{\mathit{list}}^{\mathit{cd}}$ normally has the following conditions:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $C_{\mathit{ind}}$: For $q_s$: we use the inductive invariant $\mathit{Ind}(S_{\mathit{ORS}})(q)$ of Appendix \ref{sec:appendix definitions and proofs of section succinct reference implementations of collection data types}, and (1) that for each $o_r = \mathit{rem}(a)$ there exists a $\mathit{add}(a)$, such that $o_r \in \mathit{FstRem}(o_a)$, and (3) the happen before relation is transitive.

    For $q_{\mathit{imp}}$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $a \in \mathit{data}[r].T$, then $(a,\_,\_) \in \mathit{data}[r].N$.

    \item[-] For each $a$, there exists at most one $t$, one $p$ and one $r$, such that $t = (\_,r)$, $(a,t,p) \in \mathit{data}[r'].N$ for some $r$, or $(\mathit{add},a,t,p,r,\_) \in \mathit{msgs}$.

    %\item[-] If $a$ is in $\mathit{data} \cup \mathit{msgs}$, then for each replica $r$, either $(a,\_,\_) \in \mathit{data}[r].N$, or $(\mathit{add},a,\_,\_,\_,r) \in \mathit{msgs}$.
    \end{itemize}

\item[-] $C_{\mathit{rdt}}$: $(\mathit{add},a,t)$ is redundant, if for each replica $r$, $(a,t,\_) \in \mathit{data}[r].N \wedge a \in \mathit{data}[r].T$. $(\mathit{rem},a,r)$ is redundant, if $(\mathit{add},a,t)$ is redundant for some $t$.

\item[-] $C_{\mathit{map}}$: $f$ maps $(\mathit{add},a,(\_,r))$ that are not redundant into $\mathit{add}(a)$ of replica $r$, and maps $(\mathit{rem},a,r)$ that are not redundant into $\mathit{rem}(a)$ of replica $r$.

\item[-] $C_{\mathit{msg}}$: For non redundant $(\mathit{add},a,t)$, $(\mathit{add},a,t,\_,\_,r) \in \mathit{msgs}$, if and only if $f((\mathit{add},a,r)) \notin \mathit{visTo}(O,\mathit{vis},r)$. For non redundant $(\mathit{rem},a,r)$, $(\mathit{rem}a,r,r') \in \mathit{msgs}$, if and only if $f((\mathit{rem},a,r)) \notin \mathit{visTo}(O,\mathit{vis},r)$.

\item[-] $C_{\mathit{FM}}$: $f((\mathit{rem},a,\_)) \in \mathit{FstRem}(O,\mathit{vis},f( \mathit{add},a,\_ ))$; for each $ \neq a$, $f((\mathit{rem},b,\_)) \notin \mathit{FstRem}(O,\mathit{vis},f( \mathit{add},a,\_ ))$.

\item[-] $C_{\mathit{vis}}$: $(a,t,p) \in data[r].N$, if and only if $f((\mathit{add},a,t)) \in \mathit{visTo}(O,r,\mathit{vis})$ while $t = (\_,r)$. $a \in data[r].T$, if and only if for some $t = (\_,r)$, we have $f((\mathit{add},a,t)) \in \mathit{visTo}(O,r,\mathit{vis})$, $o_r \in \mathit{FstRem}(O,\mathit{vis},f((\textit{add},a,t)))$, and $o_r \notin \mathit{visTo}(O,r,\mathit{vis})$.

\item[-] $C_{\mathit{mhb}}$: Same as that of Appendix \ref{subsec:example of or-set algorithm that assumes causal delivery}.

\item[-] $C_{\mathit{arb}}$: $\mathit{arb}$ equals applying $f$ on non-redundant elements of $f_{\mathit{arb}}(\mathit{data},\mathit{msgs})$.

\item[-] $C_{\mathit{rely}}$: If $m_1 = (\mathit{add},a,t,p,\_,r), m_2 = (\mathit{add},\_,p,\_,\_,r) \in \mathit{msgs}$, then $(m_2,m_1) \in \mathit{msghb}$. If $(\mathit{add},a,t,p,\_,r) \in \mathit{msgs}$, then $(\mathit{add},\_,p,\_,\_,r) \in \mathit{msgs} \vee (\_,p,\_) \in \mathit{data}[r].N \vee \mathit{pos}=0$. If $(\mathit{rem},a,r,r') \in \mathit{msgs}$, then $(\mathit{add},a,\_,\_,\_,r') \in \mathit{msgs} \vee (a,\_,\_) \in \mathit{data}[r].N$.
\end{itemize}


Let $\mathit{imp}_{\mathit{rga}}$ be the implementation of RGA Algorithm of \cite{Shapiro:2011} defined in Section \ref{sec:implementation}. The following lemma states that $R_{\mathit{RGA}}$ is a $f_s$-simulation relation between $ [|\mathit{imp}_{\mathit{RGA}}|]_{\mathit{cd}}$ and $\mathit{SRImp}(S_{\mathit{list}})_{\mathit{cd}}$. %Here we implicitly assume that in $q_{\mathit{imp}}$ or $q_s$, their is a ghost field that record the identifiers that can be inserted in future, and when we do $\mathit{add}(a)$, we need to ensure that $a$ is chosen from this field. This is use to enforce that each identifier is putted at most once globally.

\begin{lemma}
\label{lemma:Rrga is a fs simulation between RGA causal delivery algorithm and list specification}
$R_{\mathit{RGA}}$ is a $f_s$-simulation relation between $ [|\mathit{imp}_{\mathit{RGA}}|]_{\mathit{cd}}$ and $\mathit{SRImp}(S_{\mathit{list}})_{\mathit{cd}}$.
\end{lemma}

\begin {proof}

It is easy to see that the following property holds:

$\mathit{Prop}$: Given $k$ TI trees $x_1,\ldots,x_k$, let $x$ be their union. If $y$ (resp., $y_k$) is the sequence obtained by traversing $x$ (resp., $x_k$) with prefix order, then each $y_k$ is a sub-sequence of $y$.

Let $f_{\mathit{arb}}^v(\mathit{data},\mathit{msgs})$ be the sequences obtained from $f_{\mathit{arb}}(\mathit{data},\mathit{msgs})$ by removing redundant elements.

Assume $q_{\mathit{imp}} = (\mathit{data},\mathit{msgs},\mathit{msghb})$, $q_s = (O,\mathit{ro},\mathit{del},\mathit{arb})$, $(q_{\mathit{imp}},q_s) \in R_{\mathit{list}}$, and $q_{\mathit{imp}} \xrightarrow{\alpha}_i q'_{\mathit{imp}}$. We prove by consider all kinds of transitions.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{read},l,r,f_{\mathit{arb}}(\mathit{data},\mathit{msgs}) )}_i q_{\mathit{imp}}$: We can always do $q_s \xrightarrow{( \mathit{read},l',r,\mathit{arb} )}_s q_s$. $l = \mathit{trav}(\mathit{data}[r].N, \mathit{data}[r].T)$. By $C_{\mathit{vis}}$, $f(l)$ contains the same set of operations of $l'$. By $\mathit{Prop}$, $l$ is a subsequence of $f_{\mathit{arb}}^v(\mathit{data},\mathit{msgs})$, and thus, $f(l) = l'$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{ \mathit{msg} = \mathit{apply}( \mathit{add},a,t,p,r,r' )}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} \setminus \{ \mathit{msg} \})$. Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].N$ into $\mathit{data}[r'].N \cup \{ (a,t,p) \}$. By $C_{\mathit{rely}}$ and $C_{\mathit{mhb}}$, we can see that $(\_,p,\_) \in \mathit{data}[r'].N$, therefore, $\mathit{data}'[r'].N$ is still a TI tree.

    By $C_{\mathit{vis}}$ and $C_{\mathit{mhb}}$, we can see that $f(\mathit{add},a,t)$ is minimal w.r.t $\mathit{hb}$ in non-$\mathit{visTo}(O,\mathit{vis},r')$. Therefore, we can do $q_s \xrightarrow{ \mathit{addDel}( f(\mathit{add},a,t),r' )}_s q'_s$.

    We can see that the arbitration order of implementation and specification do not change. It is obvious that no new redundant operations are introduced in implementation and specification. By $C_{\mathit{vis}}$ and $C_{\mathit{msg}}$, we can see that $(a,t,p) \notin \mathit{data}[r'].N$, and then $C_{\mathit{vis}}$ still holds for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that other conditions also hold.


\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=( \mathit{rem},a,r,r' ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ \mathit{msg} \},\mathit{msghb}')$, and $(\mathit{rem},a,r)$ is not redundant: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].T$ into $\mathit{data}[r'].T \cup \{ a \}$.

    Let $S'' = S''_a \cup S''_r$ be the set of elements that becomes redundant during this process, while $S''_a$ contains all $\mathit{add}$ in $S''$, and $S''_r$ contains all $\mathit{rem}$ in $S''$. Let $f'$ be obtained from $f$ by minus the domain by $S''$.

    By $C_{\mathit{vis}}$ and $C_{\mathit{mhb}}$, we can see that $f(\mathit{add},a,t)$ is minimal w.r.t $\mathit{hb}$ in non-$\mathit{visTo}(O,\mathit{vis},r')$. Therefore, we can do $q_s \xrightarrow{ \mathit{addDel}( f(\mathit{rem},a,r),r' )}_s q'_s$. By $C_{\mathit{rely}}$, we can see that $(a,\_,\_) \in \mathit{data}[r'].N$, and $C_{\mathit{ind}}$ still holds for $(q'_{\mathit{imp}},q'_s)$.

    By $C_{\mathit{FM}}$ and $C_{\mathit{msg}}$, we can see that $\{ o \vert \exists x \in S'', f(S'') = o \}$ is the set that becomes ``can be forgotten'' during this process in $q_s$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$. Then, we can see that $C_{\mathit{map}}$ and $C_{\mathit{rdt}}$ holds for $(q'_{\mathit{imp}},q'_s)$.

    Since forgetting does not change visibility for the remanning operations, it is easy to see that $C_{\mathit{FM}}$ and $C_{\mathit{vis}}$ hold for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that the change of message happen before of $q_{\mathit{imp}}$ corresponding to the change of happen before of $q_s$, and then $C_{\mathit{mhb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{list}}$.

\item[-] $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=( \mathit{rem},a,r,r' ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ \mathit{msg} \},\mathit{msghb}')$, and $(\mathit{rem},a,r)$ is redundant: By $C_{\mathit{rdt}}$, $\mathit{data}' = \mathit{data}$. Since the only change is applying a message, it is easy to see that $(q'_{\mathit{imp}},q_s) \in R_{\mathit{list}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{(\mathit{add},a,\mathit{pos},r,\emptyset)}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs}',\mathit{msghb}')$: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].N$ into $\mathit{data}[r'].N \cup \{ (a,t,p) \}$, where $t=(\mathit{max}(\mathit{ts}(\mathit{data}[r].N))+1,r)$, and $p = \mathit{trav}(\mathit{data}[r].N,\mathit{data}[r].T)[\mathit{pos}]$. Here $\mathit{msgs}' = \mathit{msgs} \cup \{ (\mathit{add},a,t,p,r,r') \vert r' \neq r \}$.

    It is easy to see that from the perspective of replica $r$ of implementation, $(a,t,p)$ is at the $\mathit{pos}$-th position. %Let $\mathit{arb}'_i = f_{\mathit{arb}}(\mathit{data}',\mathit{msg}')$, and .
    It is easy to see that $a$ is previously not in $\mathit{data} \cup \mathit{msg}$, and therefore, $a$ is not in $q_s$. By $C_{\mathit{msg}}$ and $C_{\mathit{vis}}$, we can do $q_s \xrightarrow{( \mathit{add},a,\mathit{pos},r,\mathit{arb}' )}_i q'_s$ and let $o$ be the newly generated operations in $q'_s$, where $\mathit{arb}'$ is chosen to be $f_{\mathit{arb}}^v(\mathit{data}',\mathit{msgs}')$.

    It is obvious that no operation become redundant during this process. Let $f' = f \cup \{ ((a,id),,o) \}$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$. Similarly $C_{\mathit{mhb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Since there is no remove in $\mathit{FstRem}$ for $o$, and a new $\mathit{add}$ does not influence $\mathit{FstRem}$ for other operations, we have $C_{\mathit{FM}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Since $p$ is in $\mathit{data}[r].N$ or $p = \circ$, $C_{\mathit{rely}}$ holds for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that other condition also hold. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{list}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{rem},a,r,\emptyset ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs}',\mathit{msghb}')$: $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r].T$ into $\mathit{data}[r].T \cup \{ a \}$, $\mathit{msg}' = \mathit{msg} \cup \{ (\mathit{rem},a,r,r') \vert r' \neq r \}$.

    Let $S'' = S''_a \cup S''_r$ be the set of elements that becomes redundant during this process, while $S''_a$ contains all $\mathit{add}$ in $S''$, and $S''_r$ contains all $\mathit{rem}$ in $S''$. Let $f'$ be obtained from $f$ by minus the domain by $S''$.

    We already know that $(a,\_,\_) \in \mathit{data}[r].N \wedge a \notin \mathit{data}[r].T$. We already know that $f( f_{\mathit{arb}}^v(\mathit{data},\mathit{msgs}) ) = \mathit{arb}$, and it is obvious that $f_{\mathit{arb}}^v(\mathit{data}',\mathit{msgs}') = f_{\mathit{arb}}^v(\mathit{data},\mathit{msgs})$.

    By $C_{\mathit{vis}}$ and $C_{\mathit{msg}}$, we can do $q_s \xrightarrow{( \mathit{rem},a,r,\mathit{arb} )}_s q'_s$. It is obvious that $C_{\mathit{arb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. By $C_{\mathit{FM}}$ and $C_{\mathit{msg}}$, we can see that $\{ o \vert \exists x \in S'', f(S'') = o \}$ is the set that becomes ``can be forgotten'' during this process in $q_s$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$. It is obvious that $C_{\mathit{ind}}$ holds for $(q'_{\mathit{imp}},q'_s)$.

    Since forgetting does not change visibility for the remanning operations, it is easy to see that $C_{\mathit{FM}}$, $C_{\mathit{vis}}$ and $C_{\mathit{msg}}$ hold for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that $C_{\mathit{mhb}}$ holds for $(q'_{\mathit{imp}},q'_s)$. By $C_{\mathit{ind}}$ and $C_{\mathit{hb}}$, we know that $C_{\mathit{rely}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}^{\mathit{cd}}$.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}






\subsection{Example of OR-Set Algorithm of \cite{Bieniusa:2012}}
\label{subsec:example of or-set algorithm that does not assumes causal delivery}

The OR-set algorithms of \cite{Bieniusa:2012} algorithm does not assumes causal delivery. Its tuple are as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathbb{L} = \{ (E,T,\mathit{ctr}) \vert S,T \subseteq \mathbb{D} \times (\mathbb{R} \times \mathbb{N}), \mathit{ctr} \in \mathbb{N} \}$. Elements of $E$ and $T$ are of form $(a,id)$, and $\mathit{ctr}$ is per-replica counter to make $id$ unique.

\item[-] $(E,T,\mathit{ctr}) \xrightarrow[\mathit{mgs} = \{ (a,\mathit{id},r,r') \vert r' \neq r \}]{(\mathit{add},a,r)}_o (E \cup \{ (a,\mathit{id}) \}, T, \mathit{ctr}+1)$ and $\mathit{id} = (r,\mathit{ctr})$.

\item[-] $(E,T,\mathit{ctr}) \xrightarrow[\mathit{mgs} = \{ (a,S,r,r') \vert r' \neq r \} ]{(\mathit{rem},a,r)}_o (E \setminus \{ (a,\mathit{id}) \in E \}, T \cup \{ (a,\mathit{id}) \in E \}, \mathit{ctr})$, $S = \{ \mathit{id} \vert (a,\mathit{id}) \in E \} \neq \emptyset$.

\item[-] $(E,T,\mathit{ctr}) \xrightarrow[\mathit{mgs} = \emptyset]{(\mathit{lookup},a,\mathit{true},r)}_o (E,T,\mathit{ctr})$, if there exists $\mathit{id}$ such that $(a,\mathit{id}) \in E$.

\item[-] $(E,T,,\mathit{ctr}) \xrightarrow[\mathit{mgs} = \emptyset]{(\mathit{lookup},a,\mathit{false},r)}_o (E,T, \mathit{ctr})$, if $(a,\mathit{id}) \notin E$ for each $\mathit{id}$.

\item[-] $(E,T,\mathit{ctr}) \xrightarrow[\mathit{mgs} = \emptyset]{(\mathit{elements},S,r)}_o (E,T,\mathit{ctr})$, where $S = \{ a \vert \exists \mathit{id}, (a,\mathit{id}) \in E \}$.

\item[-] $(E,T,\mathit{ctr}) \xrightarrow{\mathit{apply}((a,\mathit{id},\_,r))}_m (E \cup \{ (a,\mathit{id}) \} \setminus T, T,\mathit{ctr})$.

\item[-] $(E,T,\mathit{ctr}) \xrightarrow{\mathit{apply}((a,S,\_,r))}_m (S \setminus \{ (a,\mathit{id}) \vert \mathit{id} \in S \}, T \cup \{ (a,\mathit{id}) \vert \mathit{id} \in S \}, \mathit{ctr})$.

\item[-] $d_0 = (\emptyset, \emptyset, 0)$.

\item[-] $\Sigma_e$ is the union of (1) $(a,\mathit{id})$ in either $\mathit{data}[\_].E$, $\mathit{data}[\_].T$, or $\exists (a,S',\_,\_) \in \mathit{msgs}$ and $\mathit{id} \in S'$, and (2) $(a,S,r)$ in $\mathit{msgs}$.

\item[-] $f_{\mathit{arb}}$ always return $\emptyset$.
\end{itemize}


Given a state $q_{\mathit{imp}} = (\mathit{data},\mathit{msgs},\mathit{msghb})$ of implementation and a state $q_s = (O,\mathit{ro},\mathit{del},\mathit{arb})$ of specification, $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}$ normally has the following conditions:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $C_{\mathit{ind}}$: For $q_s$: we use the inductive invariant $\mathit{Ind}(S_{\mathit{ORS}})(q)$ of Appendix \ref{sec:appendix definitions and proofs of section succinct reference implementations of collection data types}. For $q_{\mathit{imp}}$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] For each replica $r$: Let $\mathit{ID}_r = \{ k \vert \exists r' \in \mathbb{R}, (\_,(r,k)) \in \mathit{data}[r'].E \cup \mathit{data}[r'].T \} \cup \{ k \vert (\_,(r,k),\_,\_) \in \mathit{msgs} \vee ( (\_,S,\_,\_) \in \mathit{msgs} \wedge (r,k) \in S ) \}$. We require that each element of $\mathit{ID}_r$ is less than $\mathit{data}[r].\mathit{ctr}$.

    \item[-] For each replica $r$: $(a,S,r,\_) \in \mathit{msgs}$, then for each $\mathit{id} \in S$, $(a,\mathit{id}) \in \mathit{data}[r].T \wedge (a,\mathit{id},\_,r) \notin \mathit{msgs}$.
    \end{itemize}

\item[-] $C_{\mathit{rdt}}$: $(a,\mathit{id})$ is redundant, if for each replica $r$, $(a,\mathit{id}) \in \mathit{data}[r].T$. $(a,S,r)$ is redundant, if for each $\mathit{id} \in S'$, $(a,\mathit{id})$ is redundant. Moreover, if $(a,S,r)$ is redundant, and there exists a message $(a,S,r,r') \in \mathit{msgs}$, then applying this message does not change local state.

\item[-] $C_{\mathit{map}}$: $f$ maps $(a,(r,\_))$ that are not redundant into $\mathit{add}(a)$ of replica $r$, and maps $(a,S,r)$ that are not redundant into $\mathit{rem}(a)$ of replica $r$.

\item[-] $C_{\mathit{msg}}$: For non redundant $(a,\mathit{id})$, $(a,\mathit{id},\_,r) \in \mathit{msgs}$, if and only if $f((a,\mathit{id})) \notin \mathit{visTo}(O,\mathit{vis},r)$. For non redundant $(a,S,r)$, $(a,S',r,r') \in \mathit{msgs}$, if and only if $f((a,S,r)) \notin \mathit{visTo}(O,\mathit{vis},r)$.

\item[-] $C_{\mathit{FM}}$: For each $\mathit{id} \in S$, $f((a,S,r)) \in \mathit{FstRem}(O,\mathit{vis},f(a,\mathit{id}))$; while for each $\mathit{id} \notin S$, $f((a,S,r)) \notin \mathit{FstRem}(O,\mathit{vis},f(a,\mathit{id}))$.

\item[-] $C_{\mathit{vis}}$: $(a,\mathit{id}) \in data[r].E$, if and only if $f((a,\mathit{id})) \in \mathit{visTo}(O,r,\mathit{vis})$, and for each $o_r \in \mathit{FstRem}(O,\mathit{vis},f((a,\mathit{id})))$, $o_r \notin \mathit{visTo}(O,r,\mathit{vis})$.

    $(a,\mathit{id}) \in data[r].T$, if and only if there exists $o_r \in \mathit{FstRem}(O,\mathit{vis},f((a,\mathit{id})))$, such that $o_r \in \mathit{visTo}(O,r,\mathit{vis})$.
\end{itemize}

Let $\mathit{imp}_{\mathit{ORS}}$ be the implementation we just defined in this subsection. The following lemma states that $R_{\mathit{ORS}}$ is a $f_s$-simulation relation between $[|\mathit{imp}_{\mathit{ORS}}|]_{\mathit{cd}}$ and $\mathit{SRImp}(S_{\mathit{ORS}})$.


\begin{lemma}
\label{lemma:ROrscd is a fs simulation between orset causal delivery algorithm and orset specification}
$R_{\mathit{ORS}}$ is a $f_s$-simulation relation between $[|\mathit{imp}_{\mathit{ORS}}|]_{\mathit{cd}}$ and $\mathit{SRImp}(S_{\mathit{ORS}})$.
\end{lemma}

\begin {proof}

Assume $q_{\mathit{imp}} = (\mathit{data},\mathit{msgs},\mathit{msghb})$, $q_s = (O,\mathit{ro},\mathit{del},\mathit{arb})$, $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}$, and $q_{\mathit{imp}} \xrightarrow{\alpha}_i q'_{\mathit{imp}}$. We prove by consider all kinds of transitions:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{contain},a,\mathit{true},r,\emptyset )}_i q_{\mathit{imp}}$: There exists $\mathit{id}$, such that $(a,id) \in \mathit{data}[r].E$. Let $o \notin O$ be a $\mathit{contain}(a) \Rightarrow \mathit{true}$ operation of replica $r$. Let $c = (O_c,<_c,\emptyset) = f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o)$

If there exists a $\mathit{rem}(a)$ operation $o_r$, such that $(f((a,\mathit{id})),o_r) \in <_c$. By the definition of context of OR-set, we can see all the $<_c$ intermediate elements between $f((a,\mathit{id}))$ and $o_r$ are in $\mathit{visTo}(O,\mathit{vis},r)$. Let $o_1,\ldots,o_u$ be the $\mathit{add}(a)$ and $\mathit{rem}(a)$ operations among them.

If some $o_j$ is a $\mathit{rem}(a)$, then $o_j \in \mathit{FstRem}( f((a,\mathit{id})) )$, and this violates $C_{\mathit{vis}}$. If all $o_j$ are all $\mathit{add}(a)$, then $o_r \in \mathit{FstRem}( f((a,\mathit{id})) )$, and this violates $C_{\mathit{vis}}$. Therefore, such $o_r$ does not exists. Since every maximal element is $\mathit{add}(a)$, we can see that $q_s \xrightarrow{( \mathit{contain},a,\mathit{true},r,\emptyset )}_s q_s$, and recall that $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{contain},a,\mathit{false},r,\emptyset )}_i q_{\mathit{imp}}$: For each $\mathit{id}$, $(a,id) \notin \mathit{data}[r].E$. Let $o \notin O$ be a $\mathit{contain}(a) \Rightarrow \mathit{false}$ operation of replica $r$. Let $c = (O_c,<_c,\emptyset) = f_{\mathit{ctxt}}((O,\mathit{ro},\mathit{del},\mathit{arb}),o)$

If there exists a $\mathit{add}(a)$ operation $o_a$, such that $o_a$ is maximal w.r.t $<_c$. Obviously $o_a$ is not redundant, and by $C_{\mathit{vis}}$ this means that there exists $\mathit{id}$, such that $f((a,\mathit{id})) = o_a$, and $(a,\mathit{id}) \in \mathit{data}[r].E$. This contradicts the assumption. Therefore, no such $o_a$ exists. Since every  maximal element is $\mathit{rem}(a)$, we can see that $q_s \xrightarrow{( \mathit{contain},a,\mathit{false},r,\emptyset )}_i q_s$, and recall that $(q_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{elements},S,r,\emptyset )}_i q_{\mathit{imp}}$: This holds since the case of $q_{\mathit{imp}} \xrightarrow{( \mathit{contain},a,\mathit{true},r,\emptyset )}_i q_{\mathit{imp}}$ and $q_{\mathit{imp}} \xrightarrow{( \mathit{contain},a,\mathit{false},r,\emptyset )}_i q_{\mathit{imp}}$ hold.

\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=(a,\mathit{id},r,r') )}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ m \})$: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].E$ into $\mathit{data}[r'].E \cup \{ (a,\mathit{id}) \} \setminus \mathit{data}[r'].T$.

    By $C_{\mathit{msg}}$ we can see that $f((a,\mathit{id})) \notin \mathit{visTo}(O,\mathit{vis},r')$. Since $f$ is a one to one map, by $C_{\mathit{msg}}$, we can do $q_s \xrightarrow{\mathit{addDel}( f(a,\mathit{id}),r' )}_s q'_s$. By $C_{\mathit{msg}}$, the transitions do not make new element to become redundant in $q_{\mathit{imp}}$ and $q_s$. It is easy to see that all conditions still holds between $q'_{\mathit{imp}}$ and $q'_s$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=(a,S,r,r' ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ m \})$, and $(a,S,r)$ is not redundant: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].E$ into $\mathit{data}[r'].E \setminus \{ (a,\mathit{id}) \vert \mathit{id} \in S\}$ and modifying $\mathit{data}[r'].T$ into $\mathit{data}[r'].T \cup \{ (a,\mathit{id}) \vert \mathit{id} \in S\}$.

    Let $S'' = S''_a \cup S''_r$ be the set of elements that becomes redundant during this process, while $S''_a$ contains all $\mathit{add}$ in $S''$, and $S''_r$ contains all $\mathit{rem}$ in $S''$. Let $f'$ be obtained from $f$ by minus the domain by $S''$.

    By $C_{\mathit{map}}$, we know that $f((a,S',r)) \notin \mathit{visTo}(O,\mathit{vis},r')$ .Therefore, we can do $q_s \xrightarrow{\mathit{addDel}( f(a,S',r),r' )}_s q'_s$. By $C_{\mathit{FM}}$, we can see that $\{ o \vert \exists x \in S'', f(S'') = o \}$ is the set that becomes ``can be forgotten'' during this process in $q_s$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$. Then, we can see that $C_{\mathit{map}}$ and $C_{\mathit{rdt}}$ holds for $(q'_{\mathit{imp}},q'_s)$.

    Since forgetting does not change visibility for the remanning operations, it is easy to see that $C_{\mathit{FM}}$ and $C_{\mathit{vis}}$ hold for $(q'_{\mathit{imp}},q'_s)$. It is obvious that $C_{\mathit{ind}}$ still holds for $(q'_{\mathit{imp}},q'_s)$. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{\mathit{apply}( \mathit{msg}=(a,S,r,r' ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs} - \{ m \})$, and $(a,S,r)$ is redundant: By $C_{\mathit{rdt}}$, $\mathit{data}' = \mathit{data}$. Since the only change is applying a message, it is easy to see that $(q'_{\mathit{imp}},q_s) \in R_{\mathit{ORS}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{(\mathit{add},a,r,\emptyset)}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs}')$: Here $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r'].E$ into $\mathit{data}[r'].E \cup \{ (a,\mathit{id} = (r,\mathit{data}[r].\mathit{ctr})) \}$, and modifying $\mathit{data}[r].\mathit{ctr}$ into $\mathit{data}[r].\mathit{ctr}+1$. Here $\mathit{msgs}' = \mathit{msgs} \cup \{ (a,\mathit{id},r,r') \vert r' \neq r \}$. By $C_{\mathit{ind}}$ we know that it does not need to modify $\mathit{data}[r'].T$. It is obvious that we can do $q_s \xrightarrow{( \mathit{add},a,r,\emptyset )}_i q'_s$ and let $o$ be the newly generated operations in $q'_s$. It is obvious that $(a,\mathit{id})$ is not redundant in $q'_{\mathit{imp}}$. Let $f' = f \cup \{ ((a,id),,o) \}$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$.

    It is easy to see that no new operation becomes redundant in both implementation and specification. Since there is no remove in $\mathit{FstRem}$ for $o$, and a new $\mathit{add}$ does not influence $\mathit{FstRem}$ for other operations, we have $C_{\mathit{FM}}$ holds for $(q'_{\mathit{imp}},q'_s)$. It is easy to see that other condition also hold. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}$.

\item[-] If $q_{\mathit{imp}} \xrightarrow{( \mathit{rem},a,r,\emptyset ))}_i q'_{\mathit{imp}} = (\mathit{data}',\mathit{msgs}')$: Let $S' = \{ \mathit{id} \vert (a,\mathit{id}) \in \mathit{data}[r].E \}$. $\mathit{data}'$ is obtained from $\mathit{data}$ by modifying $\mathit{data}[r].E$ into $\mathit{data}[r].E \setminus \{ (a,\mathit{id}) \vert \mathit{id} \in S'\}$ and modifying $\mathit{data}[r].T$ into $\mathit{data}[r].T \cap \{ (a,\mathit{id}) \vert \mathit{id} \in S'\}$. Here $\mathit{msg}' = \mathit{msg} \cup \{ (a,S',r,r') \vert r' \neq r \}$.

    Let $S'' = S''_a \cup S''_r$ be the set of elements that becomes redundant during this process, while $S''_a$ contains all $\mathit{add}$ in $S''$, and $S''_r$ contains all $\mathit{rem}$ in $S''$. Let $f'$ be obtained from $f$ by minus the domain by $S''$.

    We already know that $S' \neq \emptyset$. By $C_{\mathit{vis}}$ and similar to the case of $\mathit{contains}(a) \Rightarrow \mathit{true}$, we can do $q_s \xrightarrow{( \mathit{rem},a,r,\emptyset )}_s q'_s$. By $C_{\mathit{FM}}$, we can see that $\{ o \vert \exists x \in S'', f(S'') = o \}$ is the set that becomes ``can be forgotten'' during this process in $q_s$. We use $f'$ for $(q'_{\mathit{imp}},q'_s)$.

    Since forgetting does not change visibility for the remanning operations, it is easy to see that $C_{\mathit{FM}}$ and $C_{\mathit{vis}}$ hold for $(q'_{\mathit{imp}},q'_s)$. By $C_{\mathit{vis}}$ and $C_{\mathit{FM}}$, we can see that $C_{\mathit{ind}}$ holds for $(q'_{\mathit{imp}},q'_s)$. Therefore, $(q'_{\mathit{imp}},q'_s) \in R_{\mathit{ORS}}$.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}

































\forget{
\section{Definitions and Proofs of Section \ref{sec:simulation relation for CRDT implementations}}
\label{sec:appendix definitions and proofs of section simulation relation for CRDT implementations}


Given a trace $t = \alpha_1 \cdot \ldots \cdot \alpha_k$ of $Sem(imp)$, $f_t(t)$ works as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] We have a state $q_s$ and a map $\mathit{map}$. Their initial value is the initial state of $SRImp(Spec)$ and $\emptyset$, respectively.

\item[-] Assume we have already dealt with $\alpha_1 \cdot \ldots \cdot \alpha_{u-1}$.

\item[-] If $\alpha_u = apply(m)$, where $m$ is of element $x$ and its destination replica is $r$: $\beta_u = addDel(map(x),r)$, and update $q_s$ with $\beta_u$.

\item[-] If $\alpha_u = (m,a,b,r,\mathit{arb}_{\mathit{imp}})$: Let $\mathit{arb}_{u-1}^s$ is the arbitration of $q_s$. If $m$ is a query or $\mathit{rem}$ operation, then $\beta_u = (m,a,b,r,\mathit{arb}_{u-1}^s)$; Else, $\beta_u = (m,a,b,r,\mathit{arb}_{u-1}^{'s})$, where $\mathit{arb}_{u-1}^{'s}$ is obtained from $\mathit{arb}_{u-1}^s$ by inserting the $add$ operation at some place, while consistent with $\mathit{arb}_{\mathit{imp}}$. After we obtain $\beta_u$, we update $q_s$ with $\beta_u$.

\item[-] $f_t(t) = \beta_k$.
\end{itemize}








Let us explain how to construct function $f_s$. $f_s$ is used to translate implementation transition label into specification transition label. It uses function $f$ to find operation of a message and to construct arbitration order. It ignores translating applying message of redundant operations. Formally, given implementation state $q_{\mathit{imp}}$, specification state $q_s$, where $(q_{\mathit{imp}},q_s) \in R_{\mathit{sim}}$, $f$ is the map between $\Sigma_e$ of $q_{\mathit{imp}}$ and operations of $q_s$, and $q_{\mathit{imp}} {\xrightarrow{\alpha}} q'_{\mathit{imp}}$. Then,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\alpha = apply(m)$: Let $m$ be message of $x \in \Sigma_e$. If $x$ is redundant, then $f_s(q_{\mathit{imp}},q_s,\alpha) = \epsilon$; Else, $f_s(q_{\mathit{imp}},q_s,\alpha) = addDel(f(x),r)$, where $r$ is the destination replica of $m$.

\item[-] $\alpha = (m,a,b,r,\mathit{arb}_{\mathit{imp}})$: $f_s(q_{\mathit{imp}},q_s,\alpha) = (m,a,b,r,\mathit{arb}'_s)$. If $m \in \mathbb{Q} \cup \{ \mathit{rem} \}$, then $\mathit{arb}'_s$ is same as the arbitration order of $q_s$; Else, assume the arbitration of $q'_{\mathit{imp}}$ is obtained from that of $q'_{\mathit{imp}}$ by inserting a new element in the $k$-th position, then $\mathit{arb}'_s$ is obtained from the arbitration order of $q_s$ by inserting $o$ at the $k$-th position, where $o=(m(a)\Rightarrow b,r,)$ is the unique possible operation for newly generated $m(a)\Rightarrow b$.
\end{itemize}

Here we implicitly assume that, when we comes to a pair of states, we change $f$ by only inserting or removing pairs of operations, not by changing existing pairs of operations. Given a trace $t = \alpha_1 \cdot \ldots \cdot \alpha_k$ of $\mathit{Sem}(\mathit{imp})$, function $f_t(t) = \beta_k$ works as follows: From the initial states $q_0^{\mathit{imp}}$ of $\mathit{Sem}(\mathit{imp})$, the initial state $q_0^{s}$ of $\mathit{SRImp}(\mathit{Spec})$, and $\alpha_1$, work as $f_s$ to obtain transition label $\beta_1$ and a new state $q_q^{s}$ of $\mathit{SRImp}(\mathit{Spec})$, and so on. The detailed definition can be found in Appendix \ref{sec:appendix definitions and proofs of section simulation and refinement}. It is easy to see that functions $f_s$ and $f_t$ hold as required.
}


























\forget
{
The $\mathit{only if}$ direction is obvious.

Let us prove the $\mathit{if}$ direction. By assumption we already have that $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$. Assume $\llbracket imp \rrbracket = (Q_{imp},\Sigma_{imp},\rightarrow_{imp},q_{0imp})$ and $RImp(Spec) = (Q_s,\Sigma_s,vis,q_{0s},li,\rightarrow_s,livReq)$. A relation $R \subseteq Q_{imp} \times Q_s$ is defined as follows: $(q_i,q_s) \in R$, if $\exists t_{imp} = \alpha_1 \cdot \ldots \cdot \alpha_k,t_s = \beta_1 \cdot \ldots \cdot \beta_k, q_{1imp}, \ldots, q_{kimp}, q_{1s}, \ldots, q_{ks}$, such that $q_{0imp} {\xrightarrow{\alpha_1}}_{imp} q_{1imp} \ldots {\xrightarrow{\alpha_k}}_{imp} q_{kimp}$ is an execution of $\llbracket imp \rrbracket$, $q_{kimp}=q_i$, $q_{0s} {\xrightarrow{\beta_1}}_s q_{1s} \ldots {\xrightarrow{\beta_k}}_s q_{ks}$ is an execution of $RImp(Spec)$, $q_{ks}=q_s$, and $t_{imp}$ and $t_s$ correspond. Let us prove that $R$ is a simulation relation. Note that, given $t_{imp}$, there exists at most one $t_s$, such that $t_{imp}$ and $t_s$ correspond.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $q_{imp} {\xrightarrow{m(a,b,r)}}_{imp} q'_{imp}$: It is easy to see that $t'_{imp} = t_{imp} \cdot m(a,b,r) \in \llbracket imp \rrbracket$.

Since $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$, there exists $t'_s$ of $RImp(Spec)$, such that $t'_{imp}$ and $t'_s$ correspond.

Since given a trace $t$ of $\llbracket imp \rrbracket$, there exists at most one trace $t'$ of $RImp(Spec)$, such that $t$ and $t'$ correspond. It is easy to see that such $t'_s$ is unique.

Since $t_{imp}$ and $t_s$ correspond and $RImp(Spec)$ is deterministic, we can see that $t'_s = t' \cdot m(a,b,r)$ is an execution of $RImp(Spec)$. Let $q_{ks} {\xrightarrow{m(a,b,r)}}_s q'_s$ It is easy to see that $t'_{imp}$ and $t'_s$ correspond. Therefore, $(q'_{imp},q'_s) \in R$.

\item[-] If $q_{imp} {\xrightarrow{apply(m)}}_{imp} q'_{imp}$: It is easy to see that $t'_{imp} = t_{imp} \cdot apply(m) \in \llbracket imp \rrbracket$.

Since $RImp(Spec)$ trace refines $\llbracket imp \rrbracket$, there exists $t'_s$ of $RImp(Spec)$, such that $t'_{imp}$ and $t'_s$ correspond.

Since given a trace $t$ of $\llbracket imp \rrbracket$, there exists at most one trace $t'$ of $RImp(Spec)$, such that $t$ and $t'$ correspond. It is easy to see that such $t'_s$ is unique.

We already know that $t_{imp}$ and $t_s$ correspond and $RImp(Spec)$ is deterministic. It is not hard to prove that, in $q_{kimp}$ and $q_{ks}$, $\forall r_1,r_2 \in RId$, the number of messages of $q_{kimp}$ which ``use source replica $r_1$ and destination replica $r_2$ and are still not applied'' is same as the number of operation of $q_{ks}$ which ``happens on replica $r_1$ and not visible to replica $r_2$''. Therefore, there exists transition $q_{ks} {\xrightarrow{addDel(o,r)}}_s q'_s$. Here $o$ and $r$ are obtained as follows: Assume after doing $t_{imp}$, $m=(\_,r',r)$ is the $i-th$ among ``messages with source replica $r'$, destination replica $r$ and still not applied'' w.r.t the occurring order of $t_{imp}$. Then, after doing $t_s$, $o$ is the $i-th$ among ``operations which happens on replica $r'$ and not visible to replica $r$'' w.r.t the occurring order of $t_s$. Let $t'_s = t' \cdot addDel(o,r)$.

Let us prove that such $m$, $o$ and $r$ satisfies the requirements in definition of simulation relation. Since we already know that $q_{0imp} {\xrightarrow{t_{imp}}}_{imp}^* q_{kimp}$ and $q_{0s} {\xrightarrow{t_s}}_s^* q_{ks}$, it is not hard to prove that, the $i-th$ message among ``messages with source replica $r'$, destination replica $r$ and still not applied'' w.r.t the occurring order of $t_{imp}$ is the same as the $i-th$ among messages of $q_{kimp}$ with source replica $r'$ and destination replica $r$ w.r.t $<_{sd}$. Similarly, we can prove that, the $i-th$ operations among ``operations which happens on replica $r'$ and not visible to replica $r$'' w.r.t the occurring order of $t_s$ is the same as the $i-th$ among operations of $q_{ks}$ which happens on replica $r'$ and not visible to replica $r$ w.r.t $ro$. Therefore, $o$ and $r$ satisfies the requirements in definition of simulation relation.

Let us prove that $(q'_{imp},q'_s) \in R$. From above discussion, it is not hard to see that $t'_{imp}$ and $t'_s$ correspond. Therefore, $(q'_{imp},q'_s) \in R$.
\end{itemize}
}


















































\forget{
Given a set $S$ of W-character, we say that $S$ is executable, if there is a order of applying all elements in $S$ with the recursive function $\mathit{insert}$. Assume there are two guard W-character $w_b$ and $w_n$. Given a set $S$ of W-characters, define a notion $\mathit{level}(S,k)$ as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{level}(S,0) = \{ (\_,\_,\_,w_b,w_e) \in S \}$.

\item[-] For $k \geq 1$, $\mathit{level}(S,k) = \{ (\_,\_,\_,w_b,w_e) \in S \vert w_b,w_e \in \mathit{level}(S,0) \cup \ldots \cup \mathit{level}(S,k-1) \} \setminus \mathit{level}(S,k-1)$.
\end{itemize}

We say $w=(\_,\_,\_,w_p,w_n)$ and $w'=(\_,\_,\_,w'_p,w'_n)$ are W-current in $\mathit{str}$, if $w,w' \in \mathit{str}$, and $w'_p <_{\mathit{str}} w <_{\mathit{str}} w'_n$ and $w_p <_{\mathit{str}} w' <_{\mathit{str}} w_n$. \cite{Oster:2006} proves that, $w <_{\mathit{str}} w'$, if and only if $w <_{\mathit{ts}} w'$.

The following lemma states that, for all possible $L$ of recursive method $\mathit{insert}$, $L$ is ordered by $<_{\mathit{ts}}$.

\begin{lemma}
\label{lemma:all possible L of insert are ordered by time stamp}
If $\mathit{str}$ is obtained from $w_b \cdot w_e$ by applying W-characters in $S$ in some order. For each pairs $w,w' \in \mathit{str}$, where index of $w$ is smaller. let $L = w \cdot w_0 \cdot \ldots \cdot w_u \cdot w'$, where $w_0,\ldots,w_u$ are the W-characters $x$ in $\mathit{str}$ such that $\mathit{pre}(x) \leq_{\mathit{str}} c_p$ and $c_n \leq_{\mathit{str}} \mathit{next}(x)$. Then, elements of $L$ are ordered by $<_{\mathit{ts}}$.
\end{lemma}

\begin {proof}

Let us prove by induction. Assume that the applying order is $w'_1,\ldots,w'_k$.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] After applying $w'_1$, this holds trivially.

\item[-] Assume that this holds after applying $w'_v$. Let us prove that this still holds after applying $w'_{v+1}$.

We prove by contradiction. Assume that after applying $w'_{v+1}$ this does not holds. Then there must exists $w'_j$ with $j < v+1$, such that either $w'_{v+1} <_{\mathit{str}} w'_j \wedge w'_j <_{\mathit{ts}} w'_{v+1}$, or $w'_j <_{\mathit{str}} w'_{v+1} \wedge w'_{v+1} <_{\mathit{ts}} w'_j$.

Since they are both in some $L$, we can see that $w'_{v+1}$ and $w'_j$ is W-concurrent. Therefore, they are ordered by $<_{\mathit{ts}}$, contradiction.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}

The following lemma states that in woot algorithm, not matter how we choose orders, as long as we can apply all W-characters, we always have an unique result.

\begin{lemma}
\label{lemma:all possible L of insert are ordered by time stamp}
Given a set $S$ of W-characters, let $\textit{str}$ and $\textit{str}'$ be obtained from $w_b \cdot w_n$ by applying W-characters in $S$ in different orders. Then, $\mathit{str} = \mathit{str}'$.
\end{lemma}

\begin {proof}

Let $\textit{str}_k$ and $\textit{str}'_k$ be obtained from $w_b \cdot w_n$ by applying all W-characters in $\mathit{level}(S,0) \cup \ldots \cup \mathit{level}(S,k)$ in different orders. We prove this lemma by proving the following property:

$\mathit{Prop}$: For each $k$, $\textit{str}_k = \textit{str}'_k$.

It is easy to see that this lemma is the case when $k$ is the largest level of $S$.

We prove $\mathit{Prop}$ by induction on $k$:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $k=0$: This holds trivially, since we need to run only one loop in $\mathit{insert}$, all elements of $\mathit{level}(S,0)$ are in this loop, and by Lemma \ref{lemma:all possible L of insert are ordered by time stamp} they are ordered by $<_{\mathit{ts}}$.

\item[-] Assume that $\textit{Prop}$ holds when $k=u$. Let us prove the case when $k = u+1$.

First, by Lemma \ref{lemma:all possible L of insert are ordered by time stamp}, it is easy to see that the order of $\mathit{level}(S,0) \cup \ldots \cup \mathit{level}(S,k)$ elements in $\textit{str}_k$ is same as that in $\textit{str}'_k$.
\end{itemize}

This completes the proof of this lemma. $\qed$
\end {proof}
}


